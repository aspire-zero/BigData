{"./":{"url":"./","title":"前言","keywords":"","body":"Introduction 面试资料 前言 安装技术文档 GitBook Copyright © 版权信息 all right reserved，powered by aspire-zero and Gitbook该文件修订时间： 2025-02-13 21:43:51 "},"Chapter1/":{"url":"Chapter1/","title":"安装软件章节","keywords":"","body":"第一章 Copyright © 版权信息 all right reserved，powered by aspire-zero and Gitbook该文件修订时间： 2025-02-12 23:35:54 "},"Chapter1/Gitbook简明安装.html":{"url":"Chapter1/Gitbook简明安装.html","title":"Gitbook简明安装","keywords":"","body":"Gitbook简明安装 1.Gitbook 简介 Gitbook (opens new window)是一个使用 Git 和 Markdown 来构建电子书籍的开源工具。它既可以生成一个静态网站，也可以输出内容作为电子书（ePub，Mobi，PDF）。Gitbook 可以在本地、Github、VPS 等平台上部署，本文采用的是借助 Node.js 在本地部署然后推送到 Github Page 托管的方式。 环境： Node.js 环境：Gitbook 在本地部署时所需要的环境。 Markdown 编辑器：推荐使用 Typora，用来编写 Gitbook 文档的具体内容。 Git 工具 +Github 账号：用于将 Gitbook 托管到 Github 存储库上。 翻墙工具：如果没有，可以私信我推荐一个我正在用的 2.Gitbook本地部署 安装node.js 因为 GitBook 是基于 Node.js 的，所以我们首先需要下载安装 Node.js (opens new window)（对应平台的.msi版本即可）注意node版本太高会影响后续安装。 测试：打开cmd，输入node -v和npm -v，若显示node和npm的版本号即安装成功。作者的分别是v20.18.0和10.8.2 截止到目前的 Gitbook V3.2.3版本，需要使用NodeJs的v10+版本，否则会产生各种报错。 这里建议下载v10.23.1版本，官网最新版本我试了也是不行的。Index of /download/release/v10.23.1/ 安装Gitbook npm install -g gitbook-cli # cmd中运行 安装完之后，就会多了一个 gitbook 命令（如果没有，请确认上面的命令是否加了 -g） 安装Git 官网下载 Git：https://www.git-scm.com/download/win(opens new window) 安装过程中一路 next 即可，安装成功后桌面右键单击出现 Git GUI Here 以及 Git Bash Here 安装typora 其他md编辑器也行，typora收费了，但有教程破解 官网下载 Typora：https://www.typora.io/(opens new window) 说明：Typora 可以配合 pandoc 插件将 Markdown 转换成其他格式的文件 3.Gitbook本地使用 初始化Gitbook 新建一个存储Gitbook的文件夹，切换到该目录下，然后初始化 gitbook init # 执行完后，你会看到多了两个文件 —— README.md 和 SUMMARY.md，它们的作用如下： README.md —— 书籍的介绍写在这个文件里 SUMMARY.md —— 书籍的目录结构在这里配置 用md编辑器编辑一个示例 编辑SUMMARY.md # 目录 - [前言](README.md) - [第一章](Chapter1/README.md) - [第1节：衣](Chapter1/衣.md) - [第2节：食](Chapter1/食.md) - [第3节：住](Chapter1/住.md) - [第4节：行](Chapter1/行.md) - [第二章](Chapter2/README.md) - [第三章](Chapter3/README.md) - [第四章](Chapter4/README.md) 在本地部署Gitbook 回到命令行，在 Gitbook 的工作区文件夹中再次执行 gitbook init 命令。GitBook 会查找 SUMMARY.md 文件中描述的目录和文件，如果没有则会将其创建。 接着我们再执行 gitbook serve 命令，将其部署在本地，打开 Chrome 访问：http://localhost:4000 (opens new window)，即可看到本地部署的 Gitbook（注：serve 命令可以指定端口 gitbook serve --port 2333） 当你写得差不多，你可以执行 gitbook build 命令构建书籍，默认将生成的静态网站输出到 _book 目录。实际上，这一步也包含在 gitbook serve 里面（注：build 命令可以指定路径 gitbook build [书籍路径] [输出路径]，如果你想查看输出目录详细的记录，可使用 gitbook build ./ --log=debug --debug 来查看） 问题： node.js版本问题 问题描述：编译时报错 polyfills.js:287 if (cb) cb.apply(this, arguments) TypeError: cb.apply is not a function 产生原因：因开发前端项目时升级了node.js版本所致，不支持这个版本的gitbook。 解决办法：一种是把node.js降级回去，第二种方式是注释掉报错代码（这个函数的作用是用来修复node.js的一些bug，用处不大） 打开C:\\Users\\xxx\\AppData\\Roaming\\npm\\node_modules\\gitbook-cli\\node_modules\\npm\\node_modules\\graceful-fs\\polyfills.js文件，找到287行的statFix函数，把它的调用处注释掉即可。 4.Gitbook配置文件 如果你想对你的网站有更详细的个性化配置或使用插件，那么需要使用配置文件。配置文件写完后，需要重启服务或者重新打包才能应用配置。Gitbook 的配置文件是book.json， 请在项目的根目录处自行创建。 4.1 配置文件主要参数 title：标题 author：作者 description：描述，对应 Gitbook 网站的 description language：使用的语言，zh-hans 是简体中文，会对应到页面的 structure：指定 Readme、Summary、Glossary 和 Languages 对应的文件名 plugins：使用的插件列表，所有的插件都在这里写出来，然后使用 gitbook install 来安装。 pluginsConfig：插件的配置信息，如果插件需要配置参数，那么在这里填写。 links：目前可以给侧导航栏添加链接信息 styles：自定义页面样式，各种格式对应各自的 css 文件 4.2 Gitbook 的常用插件 4.2.1 Gitbook 插件简介 [1] 为什么要用插件？ Gitbook 默认自带以下 5 个插件：highlight：代码高亮、search：导航栏查询功能（不支持中文）、sharing：右上角分享功能、font-settings：字体设置（最上方的\"A\"符号）、livereload：为 Gitbook 实时重新加载。Gitbook 插件可以解决一些网站不太方便的地方，如侧边栏导航不能收缩，自带搜索不支持中文等问题。 [2] 去哪里找插件？ 除了下文推荐的插件之外，Gitbook 还支持许多其他插件，可以从NPM (opens new window)上搜索 Gitbook 相关的插件。 [3] 插件安装方法： Step1：在项目的根目录中创建 book.json 文件，然后在 plugins 参数中添加插件名。 Step2：使用 gitbook install 来安装插件，重启服务 gitbook serve 或者重新打包 gitbook build 就能看见效果。 注意： 编写 json 时字符串不能用“单引号”括起，最后的那个不能有“逗号”。 如果要卸载自带的 font-settings，插件处应写成 -fontsettings，中间不要加 -。 gitbook install 命令有时会出现问题，多试几次可能就好了。 gitbook install 命令安装慢，而且是全部插件都安装一遍，如果只安装一个插件的话建议使用npm命令安装。 4.2.2 Gitbook 插件推荐 [1] 支持中文的搜索框 { \"plugins\": [ \"-lunr\", \"-search\", \"search-pro\" ], } [2] 左侧章节目录可折叠 { \"plugins\": [ \"expandable-chapters-small\" ], } [3] 侧边栏宽度可调节 { \"plugins\": [ \"splitter\" ], } [4] 回到顶部按钮 { \"plugins\": [ \"back-to-top-button\" ], } [5] 右上角添加 github 图标跳转 { \"plugins\": [ \"-sharing\", \"github\" ], \"pluginsConfig\": { \"github\": { \"url\": \"项目仓库地址\" }, } } [6] 隐藏元素 可以隐藏不想看到的元素，hide-element 是通过 HTML 元素的 class 名字来查找要隐藏的元素，想要隐藏元素找到元素的样式类名加到插件配置里面就可以隐藏元素了。 { \"plugins\": [ \"hide-element\" ], \"pluginsConfig\": { \"hide-element\": { \"elements\": [\".gitbook-link\"] }, } } 经过该配置之后，导航栏中 Published by GitBook 就被隐藏了。 [7] 代码块行号、复制 { \"plugins\": [ \"code\" ], } [8] 修改标题栏图标 { \"plugins\": [ \"favicon\" ], \"pluginsConfig\": { \"favicon\": { \"shortcut\": \"assets/images/favicon.ico\", \"bookmark\": \"assets/images/favicon.ico\", \"appleTouch\": \"assets/images/apple-touch-icon.png\", \"appleTouchMore\": { \"120x120\": \"assets/images/apple-touch-icon-120x120.png\", \"180x180\": \"assets/images/apple-touch-icon-180x180.png\" } } } } shortcut通常可以被所有可以显示favicon的浏览器读取。 bookmark是在收藏夹中显示自己的图标。 apple-touch-icon是一个类似网站favicon的图标文件，用来在iphone和iPad上创建快捷键时使用。apple-touch-icon这个文件应当是png格式，默认：57x57像素大小。如果准备的文件不是57x57的话，它会自己缩放的。 [9] 添加悬浮目录 { \"plugins\" : [ \"page-toc-button\" ], \"pluginsConfig\": { \"page-toc-button\": { \"maxTocDepth\": 2, \"minTocSize\": 2 }, } } maxTocDepth：标题的最大深度（最大支持到 2，即为 h1+h2+h3） minTocSize：显示 toc 按钮的最小 toc 条目数 [10] 添加版权信息和最后修改时间 { \"plugins\": [ \"tbfed-pagefooter\" ], \"pluginsConfig\": { \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy 版权信息\", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, } } [11] 添加RSS订阅 { \"plugins\": [ \"rss\" ], \"pluginsConfig\": { \"rss\":{ \"title\": \"标题\", \"description\": \"描述信息\", \"author\": \"作者\", \"feed_url\": \"https://xxx.xxx.xxx/rss\", \"site_url\": \"https://xxx.xxx.xxx/\" } } } 4.3 成品配置 以下是我配好的 book.json 文件，仅供参考。 { \"title\": \"标题\", \"description\": \"描述信息\", \"author\": \"作者\", \"output.name\": \"site\", \"language\": \"zh-hans\", \"gitbook\": \"3.2.3\", \"root\": \".\", \"links\": { \"sidebar\": { \"sidebar标题\": \"sidebar地址\" } }, \"plugins\": [ \"-lunr\", \"-search\", \"-sharing\", \"-fontsettings\", \"highlight\", \"livereload\", \"search-pro\", \"expandable-chapters-small\", \"splitter\", \"back-to-top-button\", \"github\", \"hide-element\", \"code\", \"custom-favicon\", \"page-toc-button\", \"tbfed-pagefooter\", \"rss\" ], \"pluginsConfig\": { \"github\": { \"url\": \"项目仓库地址\" }, \"hide-element\": { \"elements\": [\".gitbook-link\"] }, \"favicon\": { \"shortcut\": \"assets/images/favicon.ico\", \"bookmark\": \"assets/images/favicon.ico\", \"appleTouch\": \"assets/images/apple-touch-icon.png\", \"appleTouchMore\": { \"120x120\": \"assets/images/apple-touch-icon-120x120.png\", \"180x180\": \"assets/images/apple-touch-icon-180x180.png\" } }, \"page-toc-button\": { \"maxTocDepth\": 2, \"minTocSize\": 2 }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy 版权信息\", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"rss\":{ \"title\": \"标题\", \"description\": \"描述信息\", \"author\": \"作者\", \"feed_url\": \"https://xxx.xxx.xxx/rss\", \"site_url\": \"https://xxx.xxx.xxx/\" } } } 5.托管到Github Page 这部分需要使用 Git 和 Github 网站 由于 Gitbook 生成的项目跟文档的源码是两个部分，所以可以把文档放到 master 分支上，部署的网站放到 gh-pages 分支。 5.1 本地项目提交到 Github 仓库 [1] 创建git忽略文件 有些文件是不需要纳入到版本控制之中的，在项目根目录创建一个名为.gitignore的git忽略文件，编辑内容如下： # 忽略gitbook生成的项目目录 _book 下面是一些.gitignore文件忽略的匹配规则： *.a # 忽略所有 .a 结尾的文件 !lib.a # 但 lib.a 除外 /TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO build/ # 忽略 build/ 目录下的所有文件 doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 注意：.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore文件是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交。 [2] SSH KEY 由于本地 Git 仓库和 Github 仓库之间的传输是通过 SSH 加密的，所以连接时需要设置一下： Step1：先看一下 C:\\Users\\xxx 有没有.ssh 目录，有的话看下里面有没有 id_rsa 和 id_rsa.pub 这两个文件，有就跳到下一步，没有就通过下面命令创建: $ ssh-keygen -t rsa -C \"xxx@xxx.com\" 然后一路回车，这时你就会在用户下的.ssh 目录里找到 id_rsa 和 id_rsa.pub 这两个文件 Step2：登录 Github,找到右上角的图标，打开点进里面的 Settings，再选中里面的 SSH and GPG KEYS，点击右上角的 New SSH key，然后 Title 里面随便填，再把刚才 id_rsa.pub 里面的内容复制到 Title 下面的 Key 内容框里面，最后点击 Add SSH key，这样就完成了 SSH Key 的加密。 [3] 初次部署 [1] 设置用户名和邮箱 git config --global user.name \"Your Name\" git config --global user.email \"you@example.com\" [2] 连接到远程仓库并设置记住用户名和密码 git remote add origin URL # 连接到远程仓库并创建别名 git config --global credential.helper store # 设置自动记住用户名和密码（第一次push会被记住，后续无需再输入） [3] 解决使用git add命令时报错LF will be replaced by CRLF的问题 git config auto.crlf true [4] 将项目从本地提交到仓库 git init # 创建git工作区 git add . # 提交所有文件到暂存区 git status # 查看git状态 git commit -m 'description' # 提交到仓库，''内的是描述信息 [5] 将代码推送至远程仓库 git pull origin master --allow-unrelated-histories # 取回远程仓库分支的更新，再与本地的分支合并 git push -u origin master # 将本地仓库推送至远程仓库 说明： 用户名和邮箱设置：在 github 仓库主页显示谁提交了该文件，要根据 github 的注册信息来填写，不要填错了。 git init 后，在文件夹内生成.git 文件（如果没有，则 查看——勾选“隐藏的项目”） 仓库地址可在 clone or download 按钮下取得（即仓库的浏览器地址栏末尾加 .git） 使用 git pull origin master 命令报错：fatal:refusing to merge unrelated histories 错误原因：如果合并了两个不同的开始提交的仓库，在新的 git 会发现这两个仓库可能不是同一个，为了防止开发者上传错误，于是就出现了此提示。 解决办法：如我在 Github 新建一个仓库，写了 License，然后把本地一个写了很久仓库上传。这时会发现 github 的仓库和本地的没有一个共同的 commit 所以 git 不让提交，认为是写错了 origin ，如果开发者确定是这个 origin 就可以使用 --allow-unrelated-histories 告诉 git 允许不相关历史合并 使用 git push origin master 命令报错：error:failed to push some refs to URL 错误原因：直接在 GitHub 上修改后，内容已经和本地不一致了，必须要合并（merge） 解决办法：先使用 git pull origin master 命令下载到本地并合并，自动弹出的 vim 编辑器（按 i 进行编辑，说明为什么合并，可选择不修改，ESC 进入命令行模式然后输入 :wq 退出），再 git push origin master 使用 git add .命令报错：warning: LF will be replaced by CRLF 原因：在 Unix 系统中，行尾用换行（LF）表示。在窗口中，用回车（CR）和换行（LF）（CRLF）表示一行。当您从 unix 系统上载的 git 中获取代码时，它们将只有 LF。 解决办法：如果您是在 Windows 计算机上工作的单个开发人员，并且您不关心 git 自动将 LF 替换为 CRLF，则可以通过在 git 命令行中键入以下内容来关闭此警告 git config core.autocrlf true [4] 后续使用 git config auto.crlf true # 解决使用git add命令时报错LF will be replaced by CRLF的问题 git add . # 提交所有文件到暂存区 git status # 查看git状态 git commit -m 'description' # 提交到仓库，''内的是描述信息 git pull origin master # 取回远程仓库分支的更新，再与本地的分支合并 git push origin master # 将本地仓库推送至远程仓库 为了提交方便，可以创建一个脚本文件 commit.sh 来自动执行，内容如下： 目录结构： --shell ----commit.sh ----deploy.sh --content --gh-pages # 切换到上一级目录 echo '切换到上一级目录\\n' cd .. # 解决使用git add命令时报错LF will be replaced by CRLF的问题 echo '执行命令：git config auto.crlf true\\n' git config auto.crlf true # 保存所有的修改 echo '执行命令：git add -A\\n' git add -A # 把修改的文件提交 echo \"执行命令：git commit -m 'update gitbook'\\n\" git commit -m 'update gitbook' # 将本地仓库推送至远程仓库 echo '执行命令：git push origin main\\n' git push origin main # 返回到上一次的工作目录 echo \"回到刚才工作目录\" cd - 编写好后，在终端运行以下命令即可： $ bash commit.sh 5.2 上传到 Github 仓库的 gh-pages 分支 打包命令太多，为了部署方便，可以创建一个脚本文件 deploy.sh 来自动执行，内容如下： # 切换到上一级目录 echo '切换到上一级目录\\n' cd ../gh-pages git checkout gh-pages # 解决使用git add命令时报错LF will be replaced by CRLF的问题 # echo '执行命令：git config auto.crlf true\\n' # git config auto.crlf true # 保存所有的修改 echo \"执行命令：git add -A\" git add -A # 把修改的文件提交 echo \"执行命令：commit -m 'deploy gitbook'\" git commit -m 'deploy gitbook' # 发布到 https://.github.io/ echo \"执行命令：git push -f 仓库地址.git main:gh-pages\" git push git@github.com:aspire-zero/BigData.git gh-pages # 返回到上一次的工作目录 echo \"回到刚才工作目录\" cd - 注意脚本文件代码中仓库地址要替换成你自己的地址。 文件保存后，在终端执行如下命令，把生成的项目推送到 github 仓库上的 gh-pages 分支： $ bash deploy.sh 执行成功后，打开你的 github 仓库，然后选择 branch 分支，会发现多了一个 gh-pages 分支，打开这个分之后，里面会有一个 index.html 文件，说明部署的代码上传成功了。 5.3 查看 GitHub Page 网站 在 Github 网站上的项目仓库右侧，有一个 Environments，点进去之后再点击 View deployment，即可查看部署好的 GitHub Page。至此，我们的 Gitbook 就已经搭建完成了。 Copyright © 版权信息 all right reserved，powered by aspire-zero and Gitbook该文件修订时间： 2025-02-13 21:50:05 "},"Chapter2/":{"url":"Chapter2/","title":"Java有关","keywords":"","body":"第二章 Copyright © 版权信息 all right reserved，powered by aspire-zero and Gitbook该文件修订时间： 2025-02-12 23:35:54 "},"Chapter3/":{"url":"Chapter3/","title":"大数据有关","keywords":"","body":"第三章 Copyright © 版权信息 all right reserved，powered by aspire-zero and Gitbook该文件修订时间： 2025-02-12 23:35:54 "},"Chapter5/":{"url":"Chapter5/","title":"算法题有关","keywords":"","body":"第四章 Copyright © 版权信息 all right reserved，powered by aspire-zero and Gitbook该文件修订时间： 2025-02-12 23:35:54 "},"Chapter5/ACM输入输出.html":{"url":"Chapter5/ACM输入输出.html","title":"ACM输入输出","keywords":"","body":"ACM输入输出模板 输入部分分为C++和JAVA语言 牛客网在线编程算法篇输入输出练习 lower_bound 返回指向第一个值不小于 val 的位置，也就是返回第一个大于等于val值的位置。 前提是有序的情况下，upper_bound 返回第一个大于--val值的位置。 定义链表 #include using namespace std; struct ListNode{ int val; ListNode* nxt; ListNode(int _val):val(_val),nxt(nullptr){} ListNode(int _val, ListNode* _nxt):val(_val),nxt(_nxt){} } int main() { // 创建一个单链表 ListNode* head = nullptr; ListNode* pre = head; ListNode* cur = nullptr; int num; while(cin >> num) { if(num == -1) { break; } cur = new ListNode(num); if(head == nullprt) { head = cur; pre = cur; } else { pre.nxt = cur; pre = cur; } } return 0; } 定义二叉树 #include #include #include using namespace std; //定义树节点 struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode():val(0),left(nullptr),right(nullptr){} TreeNode(int _val):val(_val),left(nullptr),right(nullptr){} TreeNode(int _val,TreeNode* _left,TreeNode* _right):val(0),left(_left),right(_right){} }; //根据数组生成树 TreeNode* buildTree(const vector& v) { vector vTree(v.size(),nullptr); TreeNode* root = nullptr; for(int i = 0; i left = vTree[2 * i + 1]; vTree[i]->right = vTree[2 * i + 2]; } } return root; } int main() { // 验证 vector v = {4,1,6,0,2,5,7,-1,-1,-1,3,-1,-1,-1,8}; TreeNode* root = buildTree(v); return 0; } Copyright © 版权信息 all right reserved，powered by aspire-zero and Gitbook该文件修订时间： 2025-02-26 20:48:53 "},"Chapter5/输入数据.html":{"url":"Chapter5/输入数据.html","title":"输入数据格式","keywords":"","body":"输入数据 实现栈 输入： 6 push 1 pop top push 2 push 3 pop 输出： 1 error 3 C++ #include using namespace std; int arr[100010]; int cnt = 0; void push(int val) { arr[cnt ++] = val; } string top(){ if(cnt > n; while(n --) { string op; int val; cin >> op; if(op == \"push\") { cin >> val; push(val); } if(op == \"top\") { cout JAVA(Scnner): import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.Scanner; // 注意类名必须为 Main, 不要有任何 package xxx 信息 public class Main { public static int[] arr = new int[100010]; public static int cnt = 0; public static void push(int val) { arr[cnt ++] = val; } public static String pop() { if(cnt 0){ String op = in.next(); if(\"push\".equals(op)) { int val = in.nextInt(); push(val); } if(\"pop\".equals(op)) { System.out.println(pop()); } if(\"top\".equals(op)) { System.out.println(top()); } } in.close(); } } Java(br): br.read() 只能读一个字符，例如输入6，则int为54，也就是ASCII码 直接用readLine() import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Scanner; // 注意类名必须为 Main, 不要有任何 package xxx 信息 public class Main { public static int[] arr = new int[100010]; public static int cnt = 0; public static void push(int val) { arr[cnt ++] = val; } public static String pop() { if(cnt 0){ String[] t = br.readLine().split(\" \"); String op = t[0]; if(\"push\".equals(op)) { int val = Integer.valueOf(t[1]); push(val); } if(\"pop\".equals(op)) { System.out.println(pop()); } if(\"top\".equals(op)) { System.out.println(top()); } } br.close(); // in.close(); } } Copyright © 版权信息 all right reserved，powered by aspire-zero and Gitbook该文件修订时间： 2025-03-02 18:06:50 "},"Chapter5/非常规代码题.html":{"url":"Chapter5/非常规代码题.html","title":"非常规代码题","keywords":"","body":"多线程打印ABC 三个线程分别打印 A，B，C，要求这三个线程一起运行，打印 n 次，输出形如“ABCABCABC....”的字符串。 在if (idx == num)条件不满足时，锁会被释放，但线程会立即重新获取锁，导致忙等待（Busy Waiting），浪费CPU资源。 package Thread; import java.util.concurrent.locks.ReentrantLock; //三个线程分别打印 A，B，C，要求这三个线程一起运行，打印 n 次，输出形如“ABCABCABC....”的字符串。 public class ABC { public static int count = 12; public static int idx = 0; static ReentrantLock reentrantLock = new ReentrantLock(); public static void printABC(char c, int num){ for(int i = 1; i printABC('A', 0)); Thread thread2 = new Thread(() -> printABC('B', 1)); Thread thread3 = new Thread(() -> printABC('C', 2)); thread1.start(); thread2.start(); thread3.start(); } } 改进版，使用通知进行线程之间的交互。 package Thread; import java.util.concurrent.locks.ReentrantLock; //三个线程分别打印 A，B，C，要求这三个线程一起运行，打印 n 次，输出形如“ABCABCABC....”的字符串。 public class ABC { public static int count = 12; public static int idx = 0; static Object lock = new Object();//对象锁 public static void printABC(char c, int num){ for(int i = 1; i printABC('A', 0)); Thread thread2 = new Thread(() -> printABC('B', 1)); Thread thread3 = new Thread(() -> printABC('C', 2)); thread1.start(); thread2.start(); thread3.start(); } } 两个线程交替奇偶打印1-100 package Thread; public class EvenAndOdd { public static int idx = 1; static Object lock = new Object(); public static void printEven(boolean flag){ int c = flag ? 1 : 0; while(true){ synchronized (lock){ while(idx % 2 != c){ try { lock.wait(); } catch (InterruptedException e) { throw new RuntimeException(e); } } if(idx > 100) return; System.out.println(Thread.currentThread().getName() + \" \" + idx); idx ++; lock.notifyAll(); } } } public static void main(String[] args){ Thread thread1 = new Thread(() -> printEven(true)); Thread thread2 = new Thread(() -> printEven(false)); thread1.setName(\"even\"); thread2.setName(\"odd\"); thread1.start(); thread2.start(); } } 生产者-消费者 例如一个厨子10s生产一个，一个客人4s消费一个。 package Thread; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.BlockingQueue; public class CustomerAndProducer { public static BlockingQueue blockQueue = new ArrayBlockingQueue<>(100); public static class Producer implements Runnable{ @Override public void run() { while(true){ try { Thread.sleep(10000); blockQueue.add(\"food\"); System.out.println(\"厨师放了一个餐品\"); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } public static class Consumer implements Runnable{ @Override public void run() { while(true){ try { Thread.sleep(4000); String food = blockQueue.take(); System.out.println(\"消费者消费了一个餐品\"); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } public static void main(String[] args){ Thread thread1 = new Thread(new Producer()); Thread thread2 = new Thread(new Consumer()); thread1.start(); thread2.start(); } } 单例模式：懒汉，饿汉，双重校验锁 懒汉 package Singleton; public class Singleton { /*恶汉 private static Singleton instance = new Singleton(); private Singleton(){} public static Singleton getInstance(){ return instance; } */ /*懒汉 private static Singleton instance; private Singleton(){} public static Singleton getInstance(){ if(instance == null){ instance = new Singleton(); } } */ // 使用 volatile 关键字确保 instance 的可见性 private static volatile Singleton instance; // 私有构造函数，防止外部实例化 private Singleton() { // 初始化代码 } // 获取单例实例的静态方法 public static Singleton getInstance() { // 第一次检查，避免不必要的同步 if (instance == null) { // 加锁，确保线程安全 synchronized (Singleton.class) { // 第二次检查，防止多个线程同时通过第一次检查 if (instance == null) { instance = new Singleton(); } } } return instance; } } 随机数 有一个0-4的随机器rand4，如何实现0-6的随机器rand6，概率相同。拓展：rand X = func(rand Y)，实现func函数 Copyright © 版权信息 all right reserved，powered by aspire-zero and Gitbook该文件修订时间： 2025-03-02 18:06:49 "},"Chapter4/":{"url":"Chapter4/","title":"面试有关","keywords":"","body":"第四章 Copyright © 版权信息 all right reserved，powered by aspire-zero and Gitbook该文件修订时间： 2025-02-12 23:35:54 "},"Chapter4/算法学习.html":{"url":"Chapter4/算法学习.html","title":"算法模板","keywords":"","body":"[TOC] 基础算法 进制转化 int get(string s, int b) // 将b进制的数转化成十进制 { int res = 0; // 秦九韶算法 for (auto c: s) res = res * b + c - '0'; return res; } 排序 快速排序 void quick_sort(int q[], int l, int r) { if (l >= r) return; int i = l - 1, j = r + 1, x = q[ l + r >> 1]; while (i x); if (i 归并排序 void merge_sort(int q[], int l, int r) { if (l >= r) return; int mid = l + r >> 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i 二分 整数二分 bool check(int x) {/* ... */} // 检查x是否满足某种性质 // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： int bsearch_2(int l, int r) { while (l > 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： int bsearch_1(int l, int r) { while (l > 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; } return l; } 浮点数二分 bool check(double x) {/* ... */} // 检查x是否满足某种性质 double bsearch_3(double l, double r) { const double eps = 1e-6; // eps 表示精度，一般题目要求是1e-6时，eps是1e-8 while (r - l > eps) { double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; } return l; } 前缀和与差分 一维前缀和 #include using namespace std; const int N = 100060; int n, m, l, r, a[N], b[N]; int main() { cin >> n >> m; for (int i = 1; i > a[i]; b[i] = b[i - 1] + a[i]; } while (m--) { cin >> l >> r; cout 二维前缀和 #include using namespace std; const int N = 1005; int a[N][N], b[N][N]; int n, m, q; int main() { cin >> n >> m >> q; for (int i = 1; i > a[i][j]; b[i][j] = b[i][j - 1] + b[i - 1][j] - b[i - 1][j - 1] + a[i][j]; } } while (q--) { int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2; cout 一维差分 #include using namespace std; const int N = 100010; int n, m, a[N], b[N]; int main() { cin >> n >> m; for (int i = 1; i > a[i]; b[i] = a[i] - a[i - 1]; } while (m--) { int l, r, x; cin >> l >> r >> x; b[l] += x, b[r + 1] -= x; } for (int i = 1; i 二维差分 /* a[][]是差分矩阵，对差分矩阵求前缀和就得到了原数组，这和一维是完全一样的 不同于一维差分的是，二维差分进行修改区间需要修改四个点 a[x1][y1]+=d;进行求前缀和的时候，这会让所有x1,y1之后求的点都改变 所以要进行三个操作抵消 a[x2+1][y1]-=d,a[x1][y2+1]-=d,a[x2+1][y2+1]+=d; insert函数便诞生了 最终的数组对差分数组求二维前缀和就行 */ #include const int N = 1005; using namespace std; int n, m, q; int a[N][N], b[N][N]; void insert(int x1, int y1, int x2, int y2, int d) { a[x1][y1] += d; a[x2 + 1][y1] -= d; a[x1][y2 + 1] -= d; a[x2 + 1][y2 + 1] += d; } int main() { cin >> n >> m >> q; for (int i = 1; i > x; insert(i, j, i, j, x);//可以看成在一个小区间进行insert } } while (q--) { int x1, y1, x2, y2, d; cin >> x1 >> y1 >> x2 >> y2 >> d; insert(x1, y1, x2, y2, d); } for (int i = 1; i 高精度 加法 #include using namespace std; const int N = 1e6; vector add(vector A, vector B) { vector C; int t = 0;//进位 for (int i = 0; i > a >> b; vector A, B; for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0'); vector C = add(A, B); for (int i = C.size() - 1; i >= 0; i--) cout 减法 #include using namespace std; const int N = 1e6; bool cmp(vector a, vector b)//比较大小 { if (a.size() != b.size()) return a.size() > b.size(); for (int i = a.size() - 1; i >= 0; i--) { if (a[i] != b[i]) return a[i] > b[i]; } return true; } vector sub(vector a, vector b) { vector c; int t = 0;//借位1 for (int i = 0; i 1 && c.back() == 0) c.pop_back();//去除前导0 return c; } int main() { vector A, B, C; string a, b; cin >> a >> b; for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0'); if (cmp(A, B)) C = sub(A, B); else { cout = 0; i--) cout 乘法 大数乘小数 #include using namespace std; const int N = 1e6; vector mul(vector A, int b) { vector c; int t = 0;//进位 for (int i = 0; i 1 && c.back() == 0) c.pop_back(); return c; } int main() { string a; int b; cin >> a >> b; vector A; for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); vector c = mul(A, b); for (int i = c.size() - 1; i >= 0; i--) cout 除法 大数除小数，先输出商，在输出余数 #include using namespace std; vector div(vector &A, int B, int &r) {//r传入r的地址，便于直接对余数r进行修改 vector C; for (int i = 0; i 1 && C.back() == 0) C.pop_back(); return C; } int main() { string a; int B, r = 0; //代表余数 cin >> a >> B; vector A; for (int i = 0; i = 0; i--) cout 离散化 离散化其实就是排序+去重，然后把值映射成[0,n-1]或者[1,n]，注意此时的n是去重后的n。 映射其实就是把值放入数组（vector）中，下标就是数组下标。 alls表示所有待离散化的数。 注意处理离散化问题的时候，往往需要先把所有用到的坐标存起来并且离散化，之后在进行各种操作。 #include using namespace std; typedef pair PII; vector add, query; vector alls; int a[300010], b[300010];//最多这么多下标 int find(int x) { int l = 0, r = alls.size() - 1;//因为就是存在vector里面 while (l > 1; if (alls[mid] >= x) r = mid; else l = mid + 1; } return l + 1; } int main() { int n, m; cin >> n >> m; for (int i = 1; i > x >> c; add.push_back({x, c}); alls.push_back(x); } for (int i = 1; i > l >> r; query.push_back({l, r}); alls.push_back(l), alls.push_back(r); } sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); for (int i = 0; i 读入 string s; getline(cin,s);//空格不断行输入 stringstream ss(s); int x;//也可以改为string,double,char; while(ss >> x) cout using namespace std; int main() { int a; cin >> a; getchar(); for (int i = 1; i using namespace std; int main() { int a; cin >> a; getchar(); for (int i = 1; i 矩阵 #include #define CLOSE ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \"\\n\" typedef long long LL; const int N = 1e5 + 10, M = N, mod = 1e9 + 7; using namespace std; struct Mat{ int a[105][105]; int r, c; Mat(int _r, int _c){ r = _r, c = _c; memset(a, 0, sizeof a); } //单位矩阵 void unit(){ memset(a, 0, sizeof a); for(int i = 1; i >= 1; } return ans; } void output(){ for(int i = 1; i > m1 >> n1 >> m2 >> n2; Mat A(n1, m1), B(n2, m2); for(int i = 1; i > A.a[i][j]; } } for(int i = 1; i > B.a[i][j]; } } Mat ans = A * B; ans.output(); return 0; } STL Set/multiset set和multiset会根据特定的排序原则将元素排序。两者不同之处在于，multisets允许元素重复，而set不允许重复。 s.insert() //log(n) s.erase() //log(n) s.begin() //返回第一个元素的地址 s.end() //返回最后一个元素下一个元素的地址 s.find(x) //log(n) 返回一个地址（迭代器），如果找不到当前元素x返回s.end() s.lower_bound(x)// log(n) 返回一个元素>=x的地址（迭代器），如果找不到当前元素x返回s.end() s.upper_bound(x)// log(n) 返回一个元素>x的地址（迭代器），如果找不到当前元素x返回s.end() 二分函数 lower_bound(首地址,尾地址,x) //左闭右开，查找>=x的第一个数，若查找不到，返回尾地址 upper_bound(首地址,尾地址,x) //左闭右开，查找>x的第一个数 ，若查找不到，返回尾地址 //注意此函数返回的是地址，若要变成下标，若是数组a只需要-a,若是vector只需要-v.begin() 数据结构 字符串哈希 不能把字符映射成0，否则$A,AA,AAA$都是一样的。经验值$P=131$，或者$P=13331$，Q取成$2^{64}$,这样冲突的可能性很小。 /* 全称字符串前缀哈希法，把字符串变成一个p进制数字（哈希值），实现不同的字符串映射到不同的数字。 对形如 X1X2X3⋯Xn−1XnX1X2X3⋯Xn−1Xn 的字符串,采用字符的ascii 码乘上 P 的次方来计算哈希值。 映射公式 (X1×Pn−1+X2×Pn−2+⋯+Xn−1×P1+Xn×P0)modQ Q一般qu公式 (X1×Pn−1+X2×Pn−2+⋯+Xn−1×P1+Xn×P0)modQ Q一般 注意 1. 任意字符不可以映射成0，否则会出现不同的字符串都映射成0的情况，比如A,AA,AAA皆为0 2. 冲突问题：通过巧妙设置P (131 或 13331) , Q (2的64次方)的值，一般可以理解为不产生冲突。 公式：前缀hash h[i]=h[i-1]*P+str[i]; 区间hash h[l,r]=h[r]−h[l−1]×P(r−l+1)次方 */ #include typedef unsigned long long ULL;//代替对2的64次方取模 const int N = 1e6, P = 131;//P一般取131或者13331， using namespace std; ULL h[N], p[N];//h放的是前缀hash值，p放的是P的多少次方； int l1, r1, l2, r2, n, m; char str[N]; ULL query(int l, int r)//类似于前缀和，只不过需要一个偏移量 { return h[r] - h[l - 1] * p[r - l + 1];//公式 } int main() { scanf(\"%d%d%s\", &n, &m, str + 1);//注意s从数组的第一位开始存，类似于前缀和 h[0] = 0, p[0] = 1;//初始化，P的0次方为1 for (int i = 1; i KMP 复杂度：$O(n)$ $p$是模板串，长度为$m$，$s$是要匹配的串，长度为$n$ $next[j]$的含义，以$p[j]$为结尾，最大的后缀和前缀相等的长度，当然长度要小于$j$，否则肯定是$k$ #include using namespace std; const int N = 1e6 + 10; int ne[N], n, m; char s[N], p[N]; int main() { cin >> m >> (p + 1) >> n >> (s + 1); ne[0] = ne[1] = 0; for (int i = 2, j = 0; i 单调栈和队列 给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。 #include #define CLOSE ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) using namespace std; typedef long long ll; typedef pairPII; const int N=1e6; stack stk; int main() { CLOSE; int n; cin>>n; for(int i=1;i>x; while(!stk.empty()&&stk.top()>=x) stk.pop();//当前这个点一定不会被用到，因为x更优 if(!stk.empty()) cout 单调队列 #include using namespace std; const int N = 1e6; deque q;//双端队列 int a[N]; int main() { int n, k; cin >> n >> k; for (int i = 1; i > a[i]; for (int i = 1; i = a[i]) q.pop_back();//制作队列 q.push_back(i); while (!q.empty() && i - q.front() + 1 > k) q.pop_front();//因为要求长度是k if (i >= k) cout k) q.pop_front(); if (i >= k) cout 并查集 #include using namespace std; const int N = 1e6; int p[N], siz[N]; int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int merge(int x, int y) { int fx = find(x); int fy = find(y); if (fx != fy) { p[fx] = fy; siz[fy] += siz[fx]; } } int main() { int n, m; cin >> n >> m; for (int i = 1; i > op; if (op == \"C\") { cin >> a >> b; merge(a, b); } else if (op == \"Q1\") { cin >> a >> b; if (find(a) == find(b)) cout > a; cout DFS序 树上单点修改，子树求和问题。 dfs把子树转换成区间，子树对应的区间一定是连续的。 #include #define CLOSE ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \"\\n\" typedef long long LL; const int N = 1e6 + 10, M = 2 * N, mod = 1e9 + 7; using namespace std; int n, m, k, a[N], t[N]; int h[N], e[M], ne[M], idx; int l[N], r[N], timestamp; void add(int x, int y){ e[idx] = y, ne[idx] = h[x], h[x] = idx ++; } int lowbit(int x){return x & -x;} void addT(int x, int c){ for(int i = x; i > n >> m >> k; memset(h, -1, sizeof h); for(int i = 1; i > a[i]; for(int i = 1; i > x >> y; add(x, y), add(y, x); } dfs(k, -1); for(int i = 1; i > op >> x; if(op == 1){ cin >> y; addT(l[x], y); } else{ cout ST表 #include #define CLOSE ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \"\\n\" typedef long long LL; const int N = 2e5 + 10, M = 19, mod = 1e9 + 7; using namespace std; int f[N][M], a[N]; void init(int n){ int x = log2(n); for(int j = 0; j > n; for(int i = 1; i > a[i]; init(n); cin >> m; while(m --){ int l, r; cin >> l >> r; cout 树状数组 单点修改，区间求和 #include typedef long long LL; const int N = 5e5 + 10, M = N; using namespace std; int a[N], n, m; LL t[N]; int lowbit(int x){return x & -x;} void add(int x, int c){ for(int i = x; i > n >> m; for(int i = 1; i > a[i]; add(i, a[i]); } while(m --){ int op, x, y; cin >> op >> x >> y; if(op == 1) add(x, y); else cout 区间修改，单点查询，即维护差分数组 #include typedef long long LL; const int N = 5e5 + 10, M = N; using namespace std; int a[N], n, m; LL t[N]; int lowbit(int x){return x & -x;} void add(int x, int c){ for(int i = x; i > n >> m; for(int i = 1; i > a[i]; add(i, a[i] - a[i - 1]); } while(m --){ int op; cin >> op; if(op == 1) { int l, r, k; cin >> l >> r >> k; add(l, k), add(r + 1, -k); } else { int x; cin >> x; cout #include #define CLOSE ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \"\\n\" typedef long long LL; const int N = 1e6 + 10, M = N, mod = 1e9 + 7; using namespace std; int n, q; LL t1[N], t2[N], a[N], b[N]; int lowbit(int x) {return x & -x;} void add(int x, LL c, LL t[]){ for(int i = x; i > n >> q; for(int i = 1; i > a[i]; } for(int i = 1; i > op; if(op == 1){ int l, r; LL k; cin >> l >> r >> k; add(r + 1, -k, t1), add(l, k, t1);//改差分数组 add(r + 1, -k * (r + 1), t2), add(l, k * l, t2);//改i*差分数组 } else{ int l, r; cin >> l >> r; cout 线段树 建树复杂度 $O(n)$,其他操作$O(log(n))$ 父节点：x/2 int会自动下取整 x>>1; 左儿子：2x x 凡是只修改单点的，是不需要懒标记的，修改区间的需要懒标记。 pushup（）放在build和modify的下面 pushdown放在query和modify的上面，并且pushdown放在的是要分裂的地方； #include using namespace std; typedef long long LL; const int N = 1e5 + 100; struct node { LL l, r, sum, add; } t[N * 4];//开四倍空间 LL a[N]; void pushup(LL u)//用子节点的信息更新父亲节点 { t[u].sum = t[u > 1; build(u > 1;//这里一定不要错了，l,r是要修改的区间 if (l mid) modify(u > 1;//不要用l,r, l,r是要查询的区间左右端点 LL ans = 0; if (l mid) ans += query(u > n >> m; for (int i = 1; i > op >> l >> r; if (op == 'Q') { cout > d; modify(1, l, r, d); } } } 字典树 void insert(string s){ int p = 0; for(int i = 0; i 01字典树 cnt[p] ++，保证只用一次，用完了就不会跳到x！！ #include #define CLOSE ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \"\\n\" typedef long long LL; const int N = 3e5 + 10, M = N, mod = 1e9 + 7; using namespace std; int son[N][2], cnt[N], idx; int a[N]; void insert(int x){ int p = 0; for(int i = 30; i >= 0; i --){ int u = (x >> i) & 1; if(!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; cnt[p] ++; } } int query(int x){ int p = 0, ans = 0; for(int i = 30; i >= 0; i --){ int u = (x >> i) & 1; if(cnt[son[p][u]]){ p = son[p][u]; } else { p = son[p][u ^ 1]; ans += 1 > n; for(int i = 1; i > a[i]; } for(int i = 1; i > x; insert(x); } for(int i = 1; i 搜索 BFS bfs中的队列有两个性质 1：两段性 距离： x x x x (x+1) (x+1) (x+1) 2：单调性 bfs每次取出的队头都是距离最近的点，类似于Dijisitla， 3：只要能时时刻刻满足两段性和单调性，呢么bfs就相当于Dijisitla，所以bfs是正确的； 双端队列广搜 1：双端队列广搜解决的问题是边权是0和边权是1的问题，普通的BFS是解决边权都是1（边权相等）的问题； 2：双端队列可以说是简化版的堆优化Dijisitla，但是复杂度更优为O(n)； 3：因为有两种权重，第一次搜到的点不一定就是最短距离，与堆优化Dijkstra 一样，必须在出队时才知道每个点最终的最小值，而和一般的bfs不一样，原因是如下图所示 4.与Dijisitla不同是，他是搜索的时候用，不需要建边，不需要建图，与普通的bfs题的不同是有两种边。 #include const int N = 1006; using namespace std; struct node { int x, y; }; int a[N][N], dist[N][N], st[N][N]; int wy[4][2] = {1, 0},{-1, 0},{0, 1},{0,-1}; int qdx, qdy; int bfs() { memset(dist, 0x3f, sizeof dist); deque q; q.push_front({qdx, qdy}); dist[qdx][qdy] = 0; while (!q.empty()) { node one = q.front(); q.pop_front(); if (st[one.x][one.y]) continue; else st[one.x][one.y] = 1; for (int i = 0; i = 0 && xx = 0 && yy dist[one.x][one.y] + a[xx][yy]) { dist[xx][yy] = dist[one.x][one.y] + a[xx][yy]; if (a[xx][yy] == 1)q.push_back({xx, yy}); else q.push_front({xx, yy}); } } } } return dist[0][0]; } int main() { int n; cin >> n >> qdx >> qdy; for (int i = 1; i > x >> y; a[x][y] = 1; } cout 双向广搜 一般用于最小步数模型，最短路模型一般用不到，因为本来就不会超时，比如我们要看一个字符串十步之内是不是能变到另一个字符串，如果有六个变化方式，直接BFS是6^10,如果是双向广搜的话，只有3*6的五次方，显然是一个很大的优化，而不是简单的/2。 //字符串函数 s.substr(qd,len); #include using namespace std; string A, B, x, y; string a[7], b[7]; unordered_map da, db; queue qa, qb; int idx = 0; int extend(queue &q, unordered_map &da, unordered_map &db, string a[], string b[])//别忘了加引用符号 { string s = q.front(); q.pop(); for (int i = 0; i B { int bs; if (qa.size() > A >> B; while (cin >> x >> y) { idx++; a[idx] = x, b[idx] = y; } int ans = bfs(); if (ans == -1) puts(\"NO ANSWER!\"); else cout 图和树 二叉树 先序+中序 #include #define CLOSE ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) using namespace std; typedef long long LL; typedef pair PII; const int N = 1e3; map node; map mp; int n; int a[N], b[N]; vector v; int dfs(int l1, int r1, int l2, int r2)//先序+中序 { if (l1 > r1 || l2 > r2) return 0; int root = a[l1]; int k = mp[root]; int sum = k - l2; node[root].first = dfs(l1 + 1, l1 + sum, l2, k - 1); node[root].second = dfs(l1 + sum + 1, r1, k + 1, r2); return root; } int dfs(int l1, int r1, int l2, int r2)//后序+中序 { if (l1 > r1 || l2 > r2) return 0; int root = a[r1]; int k = mp[root]; int sum = k - l2; node[root].first = dfs(l1, l1 + sum - 1, l2, k - 1); node[root].second = dfs(l1 + sum, r1 - 1, k + 1, r2); return root; } void bfs()//层次 { queue q; q.push(a[1]); int cnt = 0; while (!q.empty()) { int t = q.front(); q.pop(); cnt++; if (cnt != n) cout > n; for (int i = 1; i > b[i]; mp[b[i]] = i; } for (int i = 1; i > a[i]; } dfs(1, n, 1, n); bfs(); return 0; } 树的直径和重心 直径 #include using namespace std; const int N = 10010, M = 20010; int h[N], ne[M], w[M], e[M], idx; int ans; // 保存最长路径 int t; // 保存找到的最远点 int n; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } void dfs(int u, int father, int dist) { for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == father) continue; dfs(j, u, dist + w[i]); } // 找到最大的dist用来更新答案ans和点t if (dist > ans) { ans = dist; t = u; } } int main() { memset(h, -1, sizeof h); scanf(\"%d\", &n); for (int i = 0; i 重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。树的重心不唯一。 定义函数$dfs(u)$，表示以$u$为根的子树的节点个数。 #include using namespace std; const int N = 100010, M = N * 2; int n; int h[N], e[M], ne[M], idx;//存图 int ans = 0x3f3f3f3f;//最终的答案 bool st[N];//表示哪些点已经被遍历过 //加边函数 void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } //dfs(u)返回的结果是以u为根的子树的节点个数 int dfs(int u) { st[u] = true;//u节点被访问过 int size = 0;//size存的是若删除u节点，剩余各个连通块中点数的最大值的最小是多少。 int sum = 1;// sum存的是以u为根的子树的节点个数，也就是dfs函数最后返回的值，初值是1 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i];//j是子节点的编号 if (st[j]) continue;//只访问没有访问过的点 int s = dfs(j);//子树的节点个数 size = max(size, s);//取一个max sum += s;//以u为根的子树的节点个数需要加上s } size = max(size, n - sum);//不要忘了父节点也构成了一个联通块 ans = min(ans, size);//更新答案 return sum; } int main() { scanf(\"%d\", &n); memset(h, -1, sizeof h);//别忘了初始化图 for (int i = 0; i 拓扑排序 #include using namespace std; const int N = 1e5 + 100, M = N; int h[N], e[M], ne[M], idx, din[N], n, m; vector v; void add(int x, int y) { e[idx] = y, ne[idx] = h[x], h[x] = idx++; } void topsort() { queue q; for (int i = 1; i > n >> m; for (int i = 1; i > x >> y; add(x, y); din[y] ++; } topsort(); if (v.size() != n) cout 最小生成树 Kruskal复杂度 $O(n*log(n))$ #include #define CLOSE ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) using namespace std; typedef long long ll; typedef pairPII; const int N=1e5+100,M=2e5+100; struct node{ int x,y,w; }edge[M]; bool cmp(node a,node b) { return a.w>n>>m; for(int i=1;i>edge[i].x>>edge[i].y>>edge[i].w; } sort(edge+1,edge+1+m,cmp);//这里排序别排错了 int sum=0,cnt=0; for(int i=1;i 次小生成树 严格次小生成树：边权之和必须小于最小生成树 非严格次小生成树，边权之和可以与最小生成树相等 //离谱，卡vector！！！ #include #define CLOSE ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) using namespace std; typedef long long ll; typedef pair PII; const int N = 1e5 + 10, M = 6e5 + 100, inf = 0x3f3f3f3f; int h[N], e[M], ne[M], w[M], idx; int f[N][18], depth[N], d1[N][18], d2[N][18], p[N]; int n, m; ll sum; void add(int x, int y, int z) { e[idx] = y, w[idx] = z, ne[idx] = h[x], h[x] = idx++; } int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } struct node { int x, y, w; bool used; } edge[M]; bool cmp(node a, node b) { return a.w q; q.push(1); while (!q.empty()) { int t = q.front(); q.pop(); for (int i = h[t]; ~i; i = ne[i]) { int j = e[i]; if (depth[j] > depth[t] + 1) { q.push(j); depth[j] = depth[t] + 1; f[j][0] = t; d1[j][0] = w[i], d2[j][0] = -inf; for (int k = 1; k d1[j][k]) { d2[j][k] = d1[j][k], d1[j][k] = distance[s]; } else if (distance[s] d2[j][k]) d2[j][k] = distance[s]; } } } } } } int lca(int x, int y, int w) { int distance[M]; int cnt = 0; if (depth[x] = 0; i--) { if (depth[f[x][i]] >= depth[y]) { distance[cnt++] = d1[x][i]; distance[cnt++] = d2[x][i]; x = f[x][i]; } } if (x != y) { for (int i = 17; i >= 0; i--) { if (f[x][i] != f[y][i]) { distance[cnt++] = d1[x][i]; distance[cnt++] = d2[x][i]; distance[cnt++] = d1[y][i]; distance[cnt++] = d2[y][i]; x = f[x][i], y = f[y][i]; } } distance[cnt++] = d1[x][0]; distance[cnt++] = d2[x][0]; distance[cnt++] = d1[y][0]; distance[cnt++] = d2[y][0]; } int dist1 = -inf, dist2 = -inf; for (int i = 0; i dist1) { dist2 = dist1, dist1 = it; } else if (it dist2) dist2 = it; } if (w > dist1) return w - dist1; else if (w > dist2) return w - dist2; else return inf; } int main() { scanf(\"%d%d\", &n, &m); for (int i = 1; i 最短路 Dijkstra 只能正权 #include typedef long long LL; const int N = 1e5 + 10, M = 2 * N; using namespace std; int h[N], e[M], ne[M], w[M], dist[N], idx; bool st[N]; int n, m; struct node{ int x, dist; }; struct cmp{ bool operator()(node a, node b){ return a.dist > b.dist; } }; void add(int x, int y, int z){ e[idx] = y, w[idx] = z, ne[idx] = h[x], h[x] = idx ++; } void dij(){ priority_queue, cmp> q; q.push({1, 0}); dist[1] = 0; while(!q.empty()){ node t = q.top(); q.pop(); if(st[t.x]) continue; st[t.x] = true; for(int i = h[t.x]; ~ i; i = ne[i]){ int j = e[i]; if(dist[j] > dist[t.x] + w[i]){ dist[j] = dist[t.x] + w[i]; q.push({j, dist[j]}); } } } } int main() { cin >> n >> m; memset(h, -1, sizeof h); memset(dist, 0x3f, sizeof dist); for(int i = 1; i > x >> y >> z; add(x, y, z); } dij(); cout 0x3f3f3f3f / 2 ? -1 : dist[n]); return 0; } 朴素版 #include using namespace std; const int N = 600; int a[N][N], bj[N], s[N]; int n, m, x, y, z; int f() { s[1] = 0; for (int i = 1; i 0x3f3f3f3f / 2) return -1; else return s[n]; } int main() { memset(a, 0x3f, sizeof a); memset(s, 0x3f, sizeof s); cin >> n >> m; for (int i = 1; i > x >> y >> z; a[x][y] = min(a[x][y], z); } int t = f(); cout Bellman-ford 给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。 请你求出从 1 号点到 n 号点的最多经过 k 条边的最短距离，如果无法从 1 号点走到 n 号点，输出 impossible。 注意：图中可能存在负权回路 。 #include #include #include using namespace std; const int N = 510, M = 10010; struct Edge{ int a, b, c; }edges[M]; int n, m, k, dist[N], last[N]; void bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i 0x3f3f3f3f / 2) puts(\"impossible\"); else printf(\"%d\\n\", dist[n]); return 0; } Spfa 负权可以 #include using namespace std; const int N = 1e5 + 100, M = N; int h[N], e[M], ne[M], w[M], idx, n, m, st[N], dist[N]; void add(int x, int y, int z) { e[idx] = y, w[idx] = z, ne[idx] = h[x], h[x] = idx++; } void spfa() { queue q; memset(dist, 0x3f, sizeof dist); dist[1] = 0; st[1] = 1; q.push(1); while (!q.empty()) { int t = q.front(); q.pop(); st[t] = 0; for (int i = h[t]; ~i; i = ne[i]) { int j = e[i]; if (dist[j] > dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) { st[j] = 1; q.push(j); } } } } } int main() { memset(h, -1, sizeof h); cin >> n >> m; for (int i = 1; i > x >> y >> z; add(x, y, z); } spfa(); if (dist[n] >= 0x3f3f3f3f / 2) cout Floyd Floyd可以解决的问题：不含负环 1：最短路 floyd实际上是一种dp，d[k,i,j]表示从i出发到达j，只经过节点编号不超过k的最短路。 呢么可以分为两种，包含节点k和不包含节点k，因为没有负环，所以floyd算的的最短路中一定没有重复点，否则就有负环。 呢么d[k,i,j]=min(d[k-1,i,j],d[k-1,i,k]+d[k-1,k,j];发现可以去掉一维 d[i,j]=min(d[i,j],d[i,k]+d[k,j]); 注意floyd中有时候要用到一个函数memcpy(d,g,sizeof g);//d是dist数组，g是原图， 因为我们跑最短路最好不要在原图上面跑，后面可能会用到原图。 memset(g,0x3f,sizeof g);//初始化 for(int i=1;i>x>>y>>z; g[x][y]=g[y][x]=min(g[x][y],z);//防止有重边 } for(int k=1;kg[i][k]+g[k][j]) g[i][j]=g[i][k]+g[k][j]; 2：传递背包：离散数学i可以到k，k可以到j，呢么i就可以到j。初始化化可以到达的点为1,不能到达的点为0。 3：最小环 我们把环分类，按照环中最大节点的编号分类。 我们开始枚举k的时候，已经求得了任意两点只经过编号为1~k-1的最短路径，这恰好可以帮助我们求环。 环一定是i-k-j这是边，然后j-…-i，这个路径只能包含1~k-1，否则环还可以更短。 所以当k固定的时候，我们只需要枚举i和j（i和j应该都小于k）。 pos[i,j]表示i到j需要经过的中间节点 #include using namespace std; const int N = 105; int g[N][N], pos[N][N], d[N][N]; int n, m; vector v; void get_pos(int x, int y)//输出x到y之间不包括x和y的道路 { if (pos[x][y] == 0) return;//x和y之间没有中间点 get_pos(x, pos[x][y]); v.push_back(pos[x][y]); get_pos(pos[x][y], y); } int main() { cin >> n >> m; memset(g, 0x3f, sizeof g);//初始化 for (int i = 1; i > x >> y >> z; g[x][y] = g[y][x] = min(g[x][y], z); } memcpy(d, g, sizeof g);//一个存图，一个跑最短路！！！ int ans = 1e9; //如果存在一个最小环的话，呢么环上的点必定不重复 for (int k = 1; k j，最大点编号为k-1的最短路 //我们把环分类，以环中最大点的编号分类,呢么环一定是 i-k-j-...-i，注意i-k-j为两个边， //我们枚举i到j就行，所以只要i-j（只经过1~k-1个点）最小就行 for (int i = 1; i (long long) d[i][j] + g[i][k] + g[k][j])//有可能0x3f3f3f3f累加爆int { v.clear(); ans = d[i][j] + g[i][k] + g[k][j]; v.push_back(i); v.push_back(k); v.push_back(j); get_pos(j, i); } } } for (int i = 1; i d[i][k] + d[k][j]) { d[i][j] = d[i][k] + d[k][j]; pos[i][j] = k; } } } } if (ans == 1e9) puts(\"No solution.\"); else { for (auto i: v) { cout 4：恰好经过k条边的最短路 判负环 （1）由于负环可能并不包含1号点，或者图不连通。所以要建立一个超级源点，从这个点向各个点连一条边权是0的边，然后进行Spfa的第一次出队更新，这等价于初始就将所有点入队。 （2）所以当存在超级源点的时候，求负环时不需要将所有点全部入队了。 （3）求负环或者正环，与dist[i]初始值无关，因为有负环dist就会被不断更新为负无穷，反之为正无穷。但是求最短路顺便判断负环的时候，dist[i]设为正无穷。求最长路顺便判断正环的时候，dist[i]设为负无穷。 #include using namespace std; const int N = 1e5 + 100, M = N; int h[N], e[M], ne[M], w[M], idx, n, m, st[N], dist[N], cnt[N]; void add(int x, int y, int z) { e[idx] = y, w[idx] = z, ne[idx] = h[x], h[x] = idx++; } bool spfa() { queue q; memset(dist, 0x3f, sizeof dist); for (int i = 1; i dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if (cnt[j] >= n) return true; if (!st[j]) { st[j] = 1; q.push(j); } } } } return false; } int main() { memset(h, -1, sizeof h); cin >> n >> m; for (int i = 1; i > x >> y >> z; add(x, y, z); } if (spfa()) cout 差分约束 只要存在一个点可以走到所有点，呢么一定可以走到所有边。 当建立超级源点的边权为0时，等价于将所有点入队。边权不为0还是得建立一个超级源点。 有超级源点了，判断负环不需要将所有点入队，这个超级源点可能是题目中有，或者你自己建立。 如果所有边权都是>=0，并且要求最长路，呢么可以用强连通分量解决，正环等价于强连通分量不存再一条>0的边 最近公共祖先 #include #define CLOSE ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \"\\n\" typedef long long LL; const int N = 1e5 + 10, M = 2 * N, mod = 1e9 + 7; using namespace std; int h[N], e[M], ne[M], idx, root, n, m; int f[N][18], depth[N]; void add(int x, int y){ e[idx] = y, ne[idx] = h[x], h[x] = idx ++; } void dfs(int u, int fa){ for(int i = h[u]; ~i; i = ne[i]){ int j = e[i]; if(j == fa) continue; depth[j] = depth[u] + 1; f[j][0] = u; for(int k = 1; k = 0; k --){ if(depth[f[x][k]] >= depth[y]){ x = f[x][k]; } } if(x == y) return x; //没有depth了 for(int k = 17; k >= 0; k --){ if(f[x][k] != f[y][k]){ x = f[x][k]; y = f[y][k]; } } return f[x][0]; } int main() { cin >> n; memset(h, -1, sizeof h); for(int i = 1; i > x >> y; if(y == -1) { root = x; continue; } add(x, y), add(y, x); } depth[root] = 1; dfs(root, -1); cin >> m; while(m --){ int x, y; cin >> x >> y; int z = lca(x, y); if(z == x) cout 树上差分 将a到b路径上的所有边全部+c，可以先d[a]+=c，d[b]+=c , d[lca(a,b)]-=2c; 最后在一遍dfs求出最终的各边权值 以x节点为根，子树的点权值之和就是x节点与之父节点的边权。 #include using namespace std; typedef long long LL; const int N = 100010, M = 2 * N; int h[N], e[M], ne[M], idx; int depth[N], d[N], f[N][18]; int n, m; LL ans; void add(int x, int y) { e[idx] = y, ne[idx] = h[x], h[x] = idx++; } void bfs() { memset(depth, 0x3f, sizeof depth); depth[0] = 0, depth[1] = 1; queue q; q.push(1); while (!q.empty()) { int t = q.front(); q.pop(); for (int i = h[t]; ~i; i = ne[i]) { int j = e[i]; if (depth[j] > depth[t] + 1) { depth[j] = depth[t] + 1; q.push(j); f[j][0] = t; for (int k = 1; k = 0; i--) { if (depth[f[x][i]] >= depth[y]) { x = f[x][i]; } } if (x == y) return x; for (int i = 17; i >= 0; i--) { if (f[x][i] != f[y][i]) { x = f[x][i]; y = f[y][i]; } } return f[x][0]; } int dfs(int x, int fa) { LL res = d[x]; for (int i = h[x]; ~i; i = ne[i]) { int j = e[i]; if (j != fa) { res += dfs(j, x); } } if (x == 1) return 0; if (res == 0) ans += m; else if (res == 1) ans += 1; return res; } int main() { cin >> n >> m; memset(h, -1, sizeof h); for (int i = 1; i > x >> y; add(x, y), add(y, x); } bfs(); for (int i = 1; i > x >> y; d[x]++, d[y]++, d[lca(x, y)] -= 2; } dfs(1, -1); cout 强连通分量 有向图 时间复杂度线性 强连通分量一定有环，但是不一定就是一个环 环一定是强连通分量 /* 1. 加时间戳； 2. 放入栈中，做好标记； 3. 遍历邻点 1）如果没遍历过，tarjan一遍，用low[j]更新最小值low 2) 如果在栈中，用dfn[j]更新最小值low 4.找到最高点 1）scc个数++ 2）do-while循环： 从栈中取出每个元素；标志为出栈； 对元素做好属于哪个scc；该scc中点的数量++ */ // tarjan 算法求强连通分量 // 时间复杂度O(n+ m) void tarjan(int u){ // 初始化自己的时间戳 dfn[u] = low[u] = ++ timestamp; //将该点放入栈中 stk[++ top] = u, in_stk[u] = true; // 遍历和u连通的点 for(int i = h[u]; ~i; i = ne[i]){ int j = e[i]; if(!dfn[j]){ tarjan(j); // 更新u所能遍历到的时间戳的最小值 low[u] = min(low[u], low[j]); } // 如果当前点在栈中 //注意栈中存的可能是树中几个不同分支的点,因为有横叉边存在 // 栈中存的所有点，是还没搜完的点，同时都不是强连通分量的最高点 // 这里表示当前强连通分量还没有遍历完，即栈中有值 else if(in_stk[j]) //更新一下u点所能到的最小的时间戳 //此时j要么是u的祖先，要么是横叉边的点，时间戳小于u low[u] = min(low[u], dfn[j]); } // 找到该连通分量的最高点 if(dfn[u] == low[u]){ int y; ++ scc_cnt; // 强连通分量的个数++ do{// 取出来该连通分量的所有点 y = stk[top --]; in_stk[y] = false; id[y] = scc_cnt; // 标记点属于哪个连通分量 size_scc[scc_cnt] ++; } while(y != u); } } #include using namespace std; const int N = 1e4 + 100, M = 5e4 + 100; int h[N], e[M], ne[M], idx, n, m; int timestamp, dfn[N], low[N], scc_size[N], id[N], scc_cnt, dout[N]; bool in_stk[N]; stack stk; void add(int x, int y) { e[idx] = y, ne[idx] = h[x], h[x] = idx++; } void tarjan(int u) { dfn[u] = low[u] = ++timestamp; stk.push(u), in_stk[u] = true; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (!dfn[j]) { tarjan(j); low[u] = min(low[j], low[u]); } else if (in_stk[j]) { low[u] = min(low[u], dfn[j]); } } if (dfn[u] == low[u]) { int y; scc_cnt++; do { y = stk.top(); stk.pop(); in_stk[y] = false; id[y] = scc_cnt; scc_size[scc_cnt]++; } while (y != u); } } int main() { memset(h, -1, sizeof h); cin >> n >> m; for (int i = 1; i > x >> y; add(x, y); } for (int i = 1; i 缩点 #include using namespace std; const int N = 1e4 + 100, M = 2e5 + 100;//记得边数翻两倍 int h[N], e[M], ne[M], idx, n, m; int hh[N]; int dfn[N], low[N], in_stk[N], timestamp, scc_cnt, scc_value[N], a[N], f[N], id[N]; stack s; void add(int h[], int x, int y) { e[idx] = y, ne[idx] = h[x], h[x] = idx++; } void tarjan(int u) { dfn[u] = low[u] = ++timestamp; s.push(u); in_stk[u] = 1; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (!dfn[j]) { tarjan(j); low[u] = min(low[u], low[j]); } else if (in_stk[j]) { low[u] = min(low[u], dfn[j]); } } if (dfn[u] == low[u]) { int y; scc_cnt++; do { y = s.top(); s.pop(); in_stk[y] = 0; id[y] = scc_cnt; scc_value[scc_cnt] += a[y]; } while (y != u); } } int main() { memset(h, -1, sizeof h); memset(hh, -1, sizeof hh); cin >> n >> m; for (int i = 1; i > a[i]; for (int i = 1; i > x >> y; add(h, x, y); } for (int i = 1; i = 1; i--) { for (int j = hh[i]; ~j; j = ne[j]) { int k = e[j]; f[k] = max(f[k], f[i] + scc_value[k]); } } int ans = -0x3f3f3f3f; for (int i = 1; i 双联通分量 无向图 割边（桥） 边的双连通分量 ： 极大的不包含桥的连通块 边的双连通分量 任何两个点之间至少存在两个不相交路径 x和y之间是桥 low[y] >dfn[x] y无论如何往上走不到x 将一个图变为边的双联通分量最少要添加几条边：缩点后，（度为1的点的个数+1）/2向下取整 void tarjan(int u, int from) { dfn[u] = low[u] = ++ timestamp; stk[ ++ top] = u; for (int i = h[u]; i!=-1; i = ne[i]) { int j = e[i]; if (!dfn[j])//j未遍历过 { tarjan(j, i);//dfs(j) low[u] = min(low[u], low[j]);//用j更新u if (dfn[u] #include using namespace std; const int N = 5010, M = 20010; int h[N], e[M], ne[M], idx, n, m; int dfn[N], low[N], id[N], dcc_cnt, timestamp; stack stk; bool is_bridge[M]; int d[N]; void add(int x, int y) { e[idx] = y, ne[idx] = h[x], h[x] = idx++; } void tarjan(int u, int from)//from表示从哪个边来的 { dfn[u] = low[u] = ++timestamp; stk.push(u); for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (!dfn[j]) { tarjan(j, i); low[u] = min(low[u], low[j]); if (low[j] > dfn[u]) is_bridge[i] = is_bridge[i ^ 1] = true;//j无论如何也走不到u，说明只有一条路径，是割边（桥） } else if (i != (from ^ 1))//肯定不能往回更新，相当于只能往下 { low[u] = min(low[u], dfn[j]); } } if (low[u] == dfn[u]) { int y; dcc_cnt++; do { y = stk.top(); stk.pop(); id[y] = dcc_cnt; } while (y != u); } } int main() { cin >> n >> m; memset(h, -1, sizeof h); for (int i = 1; i > x >> y; add(x, y), add(y, x); } for (int i = 1; i 二分图 判断 二分图存在的充分必要条件是没有奇数边的环，二分图一般指的都是无向图 时间复杂度：$O(n+m)$ 棋盘问题，很多都是二分图，$(i+j)$为偶数染成1，为奇数染成2 #include using namespace std; const int N = 2e5 + 10; int h[N], e[N], ne[N], col[N], idx, n, m, x, y;//col中，0表示未染色，1,2表示两种颜色 void add(int x, int y) { e[idx] = y; ne[idx] = h[x]; h[x] = idx++; } bool dfs(int x, int q)//x表示正在搜索哪个点，q表示要染色的颜色 { col[x] = q;//染色 for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (col[j] == 0)//如果这个点没被染过色的话 { if (dfs(j, 3 - q) == false) return false;//对这个点染色失败了，就可以返回false }//3-q可以让1和2相互转化 else if (col[j] == q) return false;//这个点已经被染过了，并且颜色和父节点相同 } return true;//不矛盾，染色成功 } int main() { memset(h, -1, sizeof h); cin >> n >> m; while (m--) { scanf(\"%d%d\", &x, &y); add(x, y), add(y, x); } int flag = 0; for (int i = 1; i 最大匹配 增广路径，从一个非匹配点出发，依次走非匹配边、匹配边、非匹配边、匹配边，最后走到一份非匹配边的算法 二分图的最大匹配等价于不存在增广路径。 实际复杂的$O(nm)$,但是实际上复杂度远小于$O(nm)$ #include using namespace std; const int N = 1e5 + 10;//match放的是女朋友对应的男朋友是谁，bj是为了防止男生重复匹配一个人 int h[N], e[N], ne[N], idx, bj[N], match[N], n1, n2, m, x, y, ans; void add(int x, int y) { e[idx] = y, ne[idx] = h[x], h[x] = idx++; } bool find(int x) { for (int i = h[x]; i != -1; i = ne[i])//遍历与这名男生相联系的女生 { int j = e[i]; if (bj[j] == 1) continue;//如果这个女生已经匹配过了，就不在匹配了 bj[j] = 1; if (match[j] == 0 || find(match[j]) == true)//如果女生没有对象，或者女生的对象还可以匹配另一个女生 { match[j] = x;//以这位女生建立关系 return true;//成功匹配，返回true } } return false;//没有找到对象，返回false } int main() { cin >> n1 >> n2 >> m; memset(h, -1, sizeof h); while (m--) { scanf(\"%d%d\", &x, &y); add(x, y); } for (int i = 1; i 二分图中： 最小点覆盖定义： 二分图中，选出最少的点，使每一条边的两个端点，至少有一个被选中。 最大独立集：二分图中，选出最多的点，使得选出的点之间没有边 最少路径覆盖：用最少的互不相交的路径，将所有点都覆盖住。 最少路径重复的覆盖： 欧拉路径（回路） 欧拉路径：是否存在一种路径，可以使所有的边恰好走一次； 欧拉回路：是否存在一种回路，是所有边恰好走一次并且回到原点 欧拉路径也就是一笔画问题，起点的度必然是奇数，终点的度也是奇数，其他点的度必须是偶数 存在欧拉路径和欧拉回路的前提是所有边联通！！！ 无向图存在欧拉路径的充分必要条件：度数为奇数的点只能为2个或者0个（起点=终点）； 无向图存在欧拉回路的充分必要条件：度数为奇数的点只能为0个； 有向图存在欧拉路径的充分必要条件：要么所有点的入度都等于出度（起点=终点）；要么除了两个点外其余的所有点，入度等于出度，这两个点，一个出度比入度多1（起点），另一个入度比出度多1（终点）； 有向图存在欧拉回路的充分必要条件：所有点的入度都等于出度； 数论 质数定理：1~n中质数的个数为$n/ln(n)$ $1~n$中能被$x$整除的个数为$\\lfloor$n/x$\\rfloor$$下取整 质数 试除法判定质数 #include using namespace std; const int N = 1e6; bool f(int x) { if (x > n; for (int i = 1; i > x; if (f(x)) cout 埃氏筛 bool st[N]; int primes[N], cnt; void init(int n) { st[0] = st[1] = true; for (int i = 2; i 线性筛法 #include #define endl \"\\n\" const int N = 1e8 + 10, M = N, mod = 1e9 + 7; using namespace std; int primes[N], cnt; bool st[N]; void init(int n){ st[0] = st[1] = true; for(int i = 2; i > n >> q; init(n); while(q --){ int k; cin >> k; cout 质因数和约数 质因数 #include using namespace std; void f(int n) { for (int i = 2; i 1) cout > n; for (int i = 1; i > x; f(x); cout 约数 试除法 #include using namespace std; void f(int x) { vector v; for (int i = 1; i > n; for (int i = 1; i > x; f(x); } return 0; } 求约数个数 $N=p_1^{\\alpha_1}p_1^{\\alpha_2}\\cdots*p_1^{\\alpha_k}$ $cnt=(\\alpha_1+1)(\\alpha_2+1)\\cdots*(\\alpha_k+1)$ #include typedef long long LL; using namespace std; const int N = 1e6, mod = 1e9 + 7; map mp; void solve(int n) { for (int i = 2; i 1) mp[n]++; } int main() { int T; cin >> T; while (T--) { int n; cin >> n; solve(n); } LL sum = 1; for (auto it: mp) { sum = sum * (it.second + 1) % mod; } cout 约数之和 $N=p_1^{\\alpha_1}p_1^{\\alpha_2}\\cdots*p_1^{\\alpha_k}$ $sum=(p_1^0+p_1^1+\\cdots+p_1^{\\alpha_1})\\cdots(p_2^0+p_2^1+\\cdots+p_2^{\\alpha_2})\\cdots(p_k^0+p_k^1+\\cdots +p_k^{\\alpha_k}) $ 如何求出$p_k^0+p_k^1+\\cdots +p_k^{\\alpha_k}$,当成$p$进制，就可以，每一位都是$1*权重$ #include using namespace std; typedef long long LL; const int N = 1e6, mod = 1e9 + 7; map mp; void solve(int n) { for (int i = 2; i 1) mp[n]++; } int main() { int T; cin >> T; while (T--) { int n; cin >> n; solve(n); } LL sum = 1; for (auto it: mp) { LL x = 0; for (int i = it.second; i >= 0; i--)//类似于进制转化 { x = (x * it.first + 1) % mod; } sum = sum * x % mod; } cout 最大公约数 欧几里得算法: $gcd(a,b)=gcd(b,a%b)$ 性质：$ d|a$，$d|b$则 $d|（a+b）$ d能整除a,d能整除b，则d能整除（a+b）很好证明，直接设就行 int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } 扩展欧几里得：求$ax+by=gcd(a,b)$的一组解 通解$x=x_0-b/d*k$ $k$是整数 ​ $y=y_0+a/d*k$ x最小非负数是多少？另$t=b/d$ 则 $x=x_0-t*k$ $x_{min}=(x_0\\%t+t)\\%t$ 如何求$ax+by=d$的解？ 有解的充分必要条件是$gcd(a,b)|d$ 扩展欧几里得求出$ax+by=gcd(a,b)$的一组解，乘上系数即可。 #include #define CLOSE ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) using namespace std; typedef long long ll; typedef pair PII; const int N = 1e6; int exgcd(int a, int b, int &x, int &y) { if (b == 0) { x = 1, y = 0; return a; } int d = exgcd(b, a % b, y, x);//交换一下顺序 y = y - a / b * x; return d; } int main() { int n; scanf(\"%d\", &n); while (n--) { int a, b, x, y; scanf(\"%d%d\", &a, &b); int d = exgcd(a, b, x, y); printf(\"%d %d\\n\", x, y); } return 0; } 欧拉函数 $\\phi(n)$为$1$~$n$直接中与$n$互质数的个数 快速幂 快速幂求逆元，要求逆元存在（a和p互质），并且p是质数。 LL qpow(LL a, LL b, LL p) { LL ans = 1; while (b) { if (b & 1) ans = ans * a % p; b >>= 1; a = a * a % p;//这里别忘了mod } return ans; } 矩阵快速幂 #include #define CLOSE ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \"\\n\" typedef long long LL; const int N = 1e5 + 10, M = N, mod = 1e9 + 7; using namespace std; struct Mat{ LL a[105][105]; int r, c; Mat(int _r, int _c){ r = _r, c = _c; memset(a, 0, sizeof a); } //单位矩阵 void unit(){ memset(a, 0, sizeof a); for(int i = 1; i >= 1; } return ans; } void output(){ for(int i = 1; i > n; Mat a(2, 2), temp(1, 2); temp.a[1][1] = temp.a[1][2] = 1, a.a[1][1] = 0, a.a[1][2] = a.a[2][1] = a.a[2][2] = 1; Mat ans = temp * a.pow(n - 2); cout 龟速乘 和快速幂思想一样，快速幂是把乘法变成乘法，龟速乘是把乘法变成加法，速度变慢了，但是不会爆long long LL qadd(LL a, LL b, LL p) { LL ans = 0; while (b) { if (b & 1) ans = (ans + a) % p; b >>= 1; a = (a + a) % p; } return ans; } 组合数 $C_n^m$ $=$ $n(n-1)(n-2)\\cdot\\cdot\\cdot(n-m+1) \\over m(m-1)\\cdot\\cdot*1$ $C_a^b=$$a!\\over b!*(a-b)!$ C[a,b]=C[a-1,b]+C[a-1,b-1]; 预处理时间复杂度：$O(N^2)$ const int N = 2005, mod = 1e9 + 7; int c[N][N]; void init() { for (int i = 0; i 预处理时间复杂度$O(N*log(N))$ #include using namespace std; typedef long long LL; const LL N = 1e5 + 8, mod = 1e9 + 7; LL fact[N], infact[N]; LL qmi(LL a, LL k, LL p) { LL ans = 1; while (k != 0) { if (k & 1) ans = ans * a % p; k = k >> 1; a = a * a % p; } return ans; } void init() { fact[0] = infact[0] = 1;//0的阶乘为1，除0的阶乘也为1 for (int i = 1; i > n; init(); while (n--) { scanf(\"%lld%lld\", &a, &b); printf(\"%lld\\n\", fact[a] * infact[b] % mod * infact[a - b] % mod);//要及时取模 } } $1 lucas #include using namespace std; typedef long long LL; int n; LL qmi(LL a, LL k, LL p) { LL ans = 1; while (k) { if (k & 1) ans = ans * a % p; k = k >> 1; a = a * a % p; } return ans; } LL p; LL c(LL a, LL b) { if (a > n; while (n--) { LL a, b; cin >> a >> b >> p; cout 容斥原理 时间复杂度$O(2^n)$ 分析，有$C_n^1+C_n^3+C_n^2+\\cdot\\cdot\\cdot+C_n^n$，可以补上一个$C_n^0$，所以有$2^n-1$项 /*容斥原理的应用 能被p1,p2,…,pm 中的至少一个数整除的整数数量 就是p1∪p2∪p3---∪pm，可以由容斥原理算出； [1,n]中能被x整除的数有[n/x]个； 其中因为p是素数，所以既能被p1整除又能被p2整除的话， 就相当于被p1*p2整除，如何枚举呢？ 采用二进制枚举法，需要枚举m个位置，所以从1枚举到pow(2,m-1);不能是从0开始枚举，因为 全是0表示都没选，不符合题意 */ #include using namespace std; typedef long long LL; const int N = 20; int a[N]; int n, m; int main() { cin >> n >> m; for (int i = 0; i > a[i]; } LL ans = 0; for (int i = 1; i n,这样不合法,但是最终答案是对的； for (int j = 0; j > j & 1) { sum++; if (t * a[j] > n) { flag = 1; break; } t = t * a[j]; } } if (flag == 0) { if (sum % 2 == 1) ans += n / t; else ans -= n / t; } } cout DP 背包问题 01背包 #include using namespace std; const int N = 1010; int n, m; int dp[N][N], v[N], w[N]; int main() { cin >> n >> m; for (int i = 1; i > v[i] >> w[i];//输入物品的体积和价值 } for (int i = 1; i 空间优化 #include using namespace std; const int N = 1010; int n, m; int dp[N], v[N], w[N]; int main(){ cin >> n >> m; for (int i = 1; i > v[i] >> w[i]; for (int i = 1; i = v[i]; j --){//从大到小枚举，注意j >= v[i]，并且是j -- dp[j] = max(dp[j], dp[j - v[i]] + w[i]); } } cout 求方案数 #include #define CLOSE ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) using namespace std; typedef long long ll; typedef pairPII; const int N=110; int f[N][10010];//从前i个里面选，恰好可以表示出来j int a[N]; int main() { int n,m; cin>>n>>m; for(int i=1;i>a[i]; f[0][0]=1; for(int i=1;ij) f[i][j]=f[i-1][j]; else f[i][j]=f[i-1][j]+f[i-1][j-a[i]]; } } cout 完全背包 时间复杂度$O(n^2)$ #include using namespace std; const int N = 1010; int n, m; int dp[N][N], v[N], w[N]; int main() { cin >> n >> m; for (int i = 1; i > v[i] >> w[i];//输入物品的体积和价值 } for (int i = 1; i 优化版本 #include using namespace std; const int N = 1010; int n, m; int dp[N], v[N], w[N]; int main(){ cin >> n >> m; for (int i = 1; i > v[i] >> w[i]; } for (int i = 1; i 求方案数 #include using namespace std; const int N = 1005; int f[2][N], w[N], v[N], n, m; int main() { cin >> n >> m; for (int i = 1; i > v[i] >> w[i]; for (int i = 1; i 多重背包 暴力写法时间复杂度$O(n^3)$ #include using namespace std; const int N = 110; int n, m; int v[N], w[N], s[N], f[N][N]; int main() { cin >> n >> m; for (int i = 1; i > v[i] >> w[i] >> s[i]; } for (int i = 1; i 二进制优化写法 时间复杂度$O(n^2*log(s))$ 建议数组开$10*n$ #include using namespace std; const int N = 12010, M = 2010;//建议N = 10 * n int n, m, cnt;//cnt是打包后的物品数量 int v[N], w[N], f[M]; int main() { cin >> n >> m; for (int i = 1; i > a >> b >> s; int k = 1; while (k 0){ cnt ++; v[cnt] = a * s; w[cnt] = b * s; } } n = cnt;//新物品的数量是cnt //这样就做01背包就行 for (int i = 1; i = v[i]; j -- ){ f[j] = max(f[j], f[j - v[i]] + w[i]); } } cout using namespace std; const int N = 2010; int n, m, f[N]; int main() { cin >> n >> m; for(int i = 1; i> a >> b >> s; //开始打包 for(int k = 1; k = k * a; j --){ f[j] = max(f[j], f[j - k * a] + k * b); } s -= k; } //剩下的就自己打包成一份 if(s){ for(int j = m; j >= s * a; j --){ f[j] = max(f[j], f[j - s * a] + s * b); } } } cout 分组背包 时间复杂度$O(n^3)$ #include using namespace std; const int N = 110; int n, m; int v[N][N], w[N][N], s[N]; int f[N][N]; int main() { cin >> n >> m; for (int i = 1; i > s[i]; for (int j = 0; j > v[i][j] >> w[i][j]; } } for (int i = 1; i = 0; j -- ){ f[i][j] = f[i - 1][j];//第i组一个都不选 for (int k = 0; k 优化空间 #include using namespace std; const int N = 110; int n, m; int v[N][N], w[N][N], s[N]; int f[N]; int main() { cin >> n >> m; for (int i = 1; i > s[i]; for (int j = 0; j > v[i][j] >> w[i][j]; } } for (int i = 1; i = 0; j -- ){ for (int k = 0; k 混合背包 混合背包就是将前面三种的背包问题混合起来，有的只能取一次，有的能取无限次，有的只能取$k$次。 先将01背包和完全背包转化成多重背包。 01背包，物品数量为1的多重背包， 完全背包，物品数量为$V_{背包体积}/v_i$的多重背包，虽然物品数量是无限的，但是背包容量是有限的。 再按照多重背包来做即可。 #include using namespace std; const int N = 1005 * 20; int f[N], w[N], v[N], n, m; int main() { int cnt = 0; cin >> n >> m; for (int i = 1; i > a >> b >> s; if (s == 0) s = m / a;//如果是完全背包，则看成多重背包做 if (s == -1)//01背包 { cnt ++; v[cnt] = a, w[cnt] = b; } else//多重背包二进制拆分 { int k = 1; while (k = v[i]; j --) f[j] = max(f[j], f[j - v[i]] + w[i]); cout 思路和代码2 01背包当成数量为1的多重背包，然后进行二进制优化。 完全背包的求法与01背包不同，所以单独算完全背包部分。 #include using namespace std; const int N = 1010; int n, m; int f[N]; int main() { cin >> n >> m; for (int i = 0; i > v >> w >> s; if (!s)//完全背包 { for (int j = v; j = k * v; j --) f[j] = max(f[j], f[j - k * v] + k * w); s -= k; } if (s) { for (int j = m; j >= s * v; j --) f[j] = max(f[j], f[j - s * v] + s * w); } } } cout 二维费用背包 #include using namespace std; const int N = 1010, K = 110; int n, V, M; int v[N], m[N], w[N]; int f[K][K]; int main() { cin >> n >> V >> M; for (int i = 1; i > v[i] >> m[i] >> w[i]; for (int i = 1; i = v[i]; -- j) { for (int k = M; k >= m[i]; -- k) { f[j][k] = max(f[j][k], f[j - v[i]][k - m[i]] + w[i]); } } } cout 区间dp 按照区间长度递增枚举，才可以dp #include using namespace std; const int N = 505; int s[N], f[N][N]; int main() { int n; cin >> n; for (int i = 1; i > x; s[i] = s[i - 1] + x; } //长度为1都是0 for (int len = 2; len 数位dp 数位DP笔记(DFS做法) - AcWing #include using namespace std; const int N = 1e6; int a[30]; int f[30][15]; int dfs(int pos, int pre, int limit, int lead) { if (!pos) return 1;//递归终点 else if (!limit && !lead && f[pos][pre] != -1) return f[pos][pre];//记忆化，只有无限制、无前导零才算，不然都是未搜索完的情况。 int res = 0, up = limit ? a[pos] : 9; for (int i = 0; i > a >> b; cout 状态压缩DP 一般要用long long #include using namespace std; typedef long long ll; typedef pair PII; const int N = 12; ll n, s, k, f[N][105][1 state;//合法的状态 vector h[1 > i) & 1 && (x >> (i + 1)) & 1)//相邻的1 { return false; } } return true; } int count(int x) { int res = 0; for (int i = 0; i > i) & 1; return res; } int main() { cin >> n >> k; for (int i = 0; i j) f[i][j][b] = f[i - 1][j][b];//类似于01背包，当前状态选不选 else f[i][j][b] += f[i - 1][j - cnt][a]; } } } } cout 博弈论 先手必胜状态：存在一种方式让对手变成先手必败状态。 先手必败状态：无论采取哪种方式，留给对手的都是先手必胜状态。 Nim游戏 先手必胜：$a_1\\bigoplus a_2 \\bigoplus \\cdots \\bigoplus a_n \\neq 0$ 先手必败：$a_1\\bigoplus a_2 \\bigoplus \\cdots \\bigoplus a_n=0$ 证明：https://www.acwing.com/solution/content/14269/ #include using namespace std; int main() { int n; cin >> n; int ans = 0; for (int i = 1; i > x; ans = ans ^ x; } if (ans) cout 台阶-Nim游戏 先手必胜：$a1\\bigoplus a_3 \\bigoplus \\cdots \\bigoplus a{2n+1} \\neq 0$ 先手必败：$a2\\bigoplus a_4 \\bigoplus \\cdots \\bigoplus a{2n}=0$ 证明：和NIm游戏类似，若奇数台阶异或不为0，我一定可以操作让奇数台阶异或变为0，之后若对手拿奇数台阶，呢么留给我的必然是异或不为0，若对手拿偶数台阶，我把他往下拿的，在往下拿，这样局面不改变。一直进行下去，必然是对手先遇到奇数台阶为0，之后对手怎么拿石子下去，我把他的石子往下拿，这样我必胜。 SG函数 $mex$运算：找到一个集合里面不存在的最小的自然数，比如$mex{1,2,3}=0$ $sg(x)=k$,则由定义地$x$可以走到的点的$sg$一定包含$[0,k-1]$里面的任何数 $sg$函数性质：多个独立局面的$sg$值，等于这些局面$sg$值的异或和 $sg=0$是先手必败状态，它只能走下$sg$不为0的状态。 $sg$不等于0，是先手必胜状态，它可以走向一个$sg$为0（必败状态） #include using namespace std; int a[105], f[10005]; int k, n; int sg(int x) { if (~f[x]) return f[x]; unordered_set s; for (int i = 1; i = 0) s.insert(sg(x - a[i])); } for (int i = 0;; i++) { if (!s.count(i)) return f[x] = i; } } int main() { memset(f, -1, sizeof f); cin >> k; for (int i = 1; i > a[i]; cin >> n; int res = 0; for (int i = 1; i > x; res ^= sg(x); } if (res) cout Copyright © 版权信息 all right reserved，powered by aspire-zero and Gitbook该文件修订时间： 2025-02-22 18:26:10 "},"Chapter4/算法题.html":{"url":"Chapter4/算法题.html","title":"面试算法题","keywords":"","body":" 输入n个整数，进行加减组合，能够组成计算结果为s的方案数 #include #include #include using namespace std; int main(){ int n, s; int a[i]; int dp[2][2000]; cin >> n; int tot = 0; for(int i = 0; i > a[i]; tot += (a[i] >= 0 ? a[i] : -a[i]); } cout = a[i]) { dp[t][j] = dp[k][j - a[i]]; } if(j + a[i] # 题目，给你一堆信封大小，问你最多能相互套多少个，只有第二的信封长和宽都大于前一个才能套进去。 排序加单调队列 #include #include #include using namespace std; vector> q; struct cmp{ bool operator()(const vector& a, const vector& b)const { if(a[0] == b[0]) return a[1] > b[1]; return a[0] >& envelopes) { int n = envelopes.size(); if(n f = {envelopes[0][1]}; for(int i = 1; i f.back()) { f.emplace_back(num); } else { int l = 0, r = f.size(); while(l > 1; if(f[mid] >= num) { r = mid; } else { l = mid + 1; } } cout > n; for(int i = 0; i > x >> y; q.push_back({x, y}); } ans = maxEnvelopes(q); cout 给你一个单向链表，获得倒数第n个值 思路：通过快慢指针进行计算 Copyright © 版权信息 all right reserved，powered by aspire-zero and Gitbook该文件修订时间： 2025-02-26 21:14:07 "},"Chapter4/面试题.html":{"url":"Chapter4/面试题.html","title":"面试题","keywords":"","body":"11. java创建对象有哪些方式？ 1. 使用new关键字 2. 反序列化对象数据 3. 反射机制：Class类的forName方法的newInstance() 4. 反射机制: 对应类的getConstructor()的newInstance() 5. 通过clone()函数复制，必须实现Cloneable接口 4. 获取 Class 对象的四种方式 1. 直接该类名称的.class 2. 通过Class.forName传入类的全路径获取 3. 通过对象实例getClass函数获取 4. 通过类加载器ClassLoader.loadClass()传入类的路径获取 3. 动态代理 就是给已经开发好的实体类增加功能的手段，不改变原有的处理逻辑 jdk动态代理类使用步骤 1.定义一个接口及其实现类； 2.自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑； 3.通过 Proxy.newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h) 方法创建代理对象； JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。 GCLIB动态代理类使用步骤 1.定义一个类 2.自定义MethodIntercepter并重写intercept方法， 用于拦截增强被代理类的方法，和JDK动态代理的invoke方法类似 3. 通过Enhancer类的create创建代理类 写一个线程安全的懒加载单例 import java.util.Scanner; class Main{ private volatile static Main instance; public Main() { } public static Main getInstance() { if(instance == null) { synchronized (Main.class) { if(instance == null) { instance = new Main(); } } } return instance; } } 2. I/O 流为什么要分为字节流和字符流呢? 防止转换成字节流进行信息交互，出现乱码问题 为什么ArrayList不是线程安全的，具体来说是哪里不安全？ 不是 arraylist大体分三部分： 需不需要扩容 size位置设置值 将当前集合的大小加1 部分值为null 索引越界异常 size与add数量不一致 2. 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同 线程不安全，都是实现set接口 Hashset是哈希表 LinkedHashset是哈希表+链表，保证了插入和取出顺序满足FIFO TreeSet是红黑树 1. HashMap 和 Hashtable 的区别 线程安全：HashMap不安全，HashTable安全 效率：HashMap效率会高 对null key和nullvalue 支持：HashMap支持，HashTable不支持 初始容量和每次扩容容量大小不同：① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。 底层结构：JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。Hashtable 没有这样的机制。 哈希函数的实现：HashMap 对哈希值进行了高位和低位的混合扰动处理以减少冲突，而 Hashtable 直接使用键的 hashCode() 值。 HashMap 的底层实现 HashMap 的长度为什么是 2 的幂次方 位运算效率更高：位运算(&)比取余运算(%)更高效。当长度为 2 的幂次方时，hash % length 等价于 hash & (length - 1)。 可以更好地保证哈希值的均匀分布：扩容之后，在旧数组元素 hash 值比较均匀的情况下，新数组元素也会被分配的比较均匀，最好的情况是会有一半在新数组的前半部分，一半在新数组后半部分。 扩容机制变得简单和高效：扩容后只需检查哈希值高位的变化来决定元素的新位置，要么位置不变（高位为 0），要么就是移动到新位置（高位为 1，原索引位置+原容量）。 位运算效率更高，数据分布更均匀，扩容机制变得简单 列举HashMap在多线程下可能会出现的问题？ 尾插法：会出现数据覆盖 头插法：会在扩容机制中出现死循环，扩容后需要重新分配位置 6. 列举HashMap在多线程下可能会出现的问题？ 7. ConcurrentHashMap 和 Hashtable 的区别 底层数据结构：分段数组和链表。jdk8之后是数组和链表/红黑树；hashtable是数组和链表 实现线程安全的方式：ConcurrentHashMap直接对node加锁 cas； hashtable是整个一把锁，效率低下，使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。 ConcurrentHashMap已经用了synchronized，为什么还要用CAS（乐观锁）呢 为什么HashMap要用红黑树而不是平衡二叉树？ 平衡二叉树追求的是一种 “完全平衡” 状态：任何结点的左右子树的高度差不会超过 1，优势是树的结点是很平均分配的。这个要求实在是太严了，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。 红黑树不追求这种完全平衡状态，而是追求一种 “弱平衡” 状态：整个树最长路径不会超过最短路径的 2 倍。优势是虽然牺牲了一部分查找的性能效率，但是能够换取一部分维持树平衡状态的成本。与平衡树不同的是，红黑树在插入、删除等操作，不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整，这也是我们为什么大多数情况下使用红黑树的原因。 HashMap的扩容机制介绍一下 hashMap默认的负载因子是0.75，即如果hashmap中的元素个数超过了总容量75%，则会触发扩容，扩容分为两个步骤： 第1步是对哈希表长度的扩展（2倍） 第2步是将旧哈希表中的数据放到新的哈希表中。 只需要看原来的hash值新增的那个bit是0还是1，0是不动，1是移动原始容量距离 请简要描述线程与进程的关系,区别及优缺点？ 线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。 线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。 线程执行开销小，但不利于资源的管理和保护；而进程正相反。 有了进程为什么还需要线程? 进程切换是一个开销很大的操作，线程切换的成本较低。 线程更轻量，一个进程可以创建多个线程。 多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回。 同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核 4. 如何创建线程？ 继承Thread，实现Runnable接口、实现Callable接口，实现线程池 最终都是 new Thread.start() 说说线程的生命周期和状态? 初始 运行 阻塞 等待 超时等待 终止 7. Thread#sleep() 方法和 Object#wait() 方法对比 共同点：两者都可以暂停线程的执行。 区别： sleep() 方法没有释放锁，而 wait() 方法释放了锁 。 wait() 通常被用于线程间交互/通信，sleep()通常被用于暂停执行。 wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify()或者 notifyAll() 方法。sleep()方法执行完成后，线程会自动苏醒，或者也可以使用 wait(long timeout) 超时后线程会自动苏醒。 sleep() 是 Thread 类的静态本地方法，wait() 则是 Object 类的本地方法。 3. 并发编程三个重要特性 原子性： 可见性：修改是可见的 有序性：volatile关键字可以禁止指令进行重排序优化。 4. volatile 关键字 4. 如何实现乐观锁？ 版本号控制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功 CAS:CAS 涉及到三个操作数： V：要更新的变量值(Var) E：预期值(Expected) N：拟写入的新值(New) 4. synchronized 和 volatile 有什么区别？ 互补 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。 volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。 volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。 synchronized 和 ReentrantLock 有什么区别？ 都是可重入锁 synchronized是依赖于JVM，ReentrantLoack依赖于API synchronized是非公平的，ReentrantLoack可以是公平或者非公平 ReentrantLoack可实现等待可中断 可实现选择性通知（锁可以绑定多个条件）: synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。 支持超时 ：ReentrantLock 提供了 tryLock(timeout) 的方法，可以指定等待获取锁的最长等待时间，如果超过了等待时间，就会获取锁失败，不会一直等待 ThreadLocal 内存泄露问题是怎么导致的？如何避免？ ThreadLocal 实例不再被强引用；key为null 线程持续存活，导致 ThreadLocalMap 长期存在。 如何避免： 在使用完 ThreadLocal 后，务必调用 remove() 方法。 这是最安全和最推荐的做法。 remove() 方法会从 ThreadLocalMap 中显式地移除对应的 entry，彻底解决内存泄漏的风险。 即使将 ThreadLocal 定义为 static final，也强烈建议在每次使用后调用 remove()。 在线程池等线程复用的场景下，使用 try-finally 块可以确保即使发生异常，remove() 方法也一定会被执行。 5. 如何跨线程传递 ThreadLocal 的值？ InheritableThreadLocal ：InheritableThreadLocal 是 JDK1.2 提供的工具，继承自 ThreadLocal 。使用 InheritableThreadLocal 时，会在创建子线程时，令子线程继承父线程中的 ThreadLocal 值，但是无法支持线程池场景下的 ThreadLocal 值传递。 TransmittableThreadLocal ： TransmittableThreadLocal （简称 TTL） 是阿里巴巴开源的工具类，继承并加强了InheritableThreadLocal类，可以在线程池的场景下支持 ThreadLocal 值传递 3. 如何创建线程池？常用方法 start启动线程，线程池：submit对于callable，execute对于runable。 7. 线程池的拒绝策略有哪些？ 12. 线程池中线程异常后，销毁还是复用？ 3. 一个任务需要依赖另外两个任务执行完之后再执行，怎么设计？ 1. 对象的创建过程 内存分配和回收原则 死亡对象判断方法 4. 如何判断一个常量是废弃常量？ 如何判断一个类是无用的类？ 垃圾收集算法 垃圾收集器 类加载过程 JVM 中内置了三个重要的 ClassLoader 类加载器和双亲委派机制。 1. 说说自己对于 Spring MVC 了解? MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。 3. 将一个类声明为 Bean 的注解有哪些? @Component：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。 @Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。 @Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。 @Controller : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。 11. Bean 的生命周期了解么? 创建 Bean 的实例：Bean 容器首先会找到配置文件中的 Bean 定义，然后使用 Java 反射 API 来创建 Bean 的实例。 Bean 属性赋值/填充：为 Bean 设置相关属性和依赖，例如@Autowired 等注解注入的对象、@Value 注入的值、setter方法或构造函数注入依赖和值、@Resource注入的各种资源。 Bean 初始化 如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入 Bean 的名字。 如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。 如果 Bean 实现了 BeanFactoryAware 接口，调用 setBeanFactory()方法，传入 BeanFactory对象的实例。 与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法 如果 Bean 实现了InitializingBean接口，执行afterPropertiesSet()方法。 如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法。 销毁 Bean ：销毁并不是说要立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。 如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。 如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的 Bean 销毁方法。或者，也可以直接通过@PreDestroy 注解标记 Bean 销毁之前执行的方法。 整体上可以简单分为四步：实例化 —> 属性赋值 —> 初始化 —> 销毁。 初始化这一步涉及到的步骤比较多，包含 Aware 接口的依赖注入、BeanPostProcessor 在初始化前后的处理以及 InitializingBean 和 init-method 的初始化操作。 销毁这一步会注册相关销毁回调接口，最后通过DisposableBean 和 destory-method 进行销毁。 3. SpringMVC 工作原理了解吗? 客户端（浏览器）发送请求， DispatcherServlet拦截请求。 DispatcherServlet 根据请求信息调用 HandlerMapping 。HandlerMapping 根据 URL 去匹配查找能处理的 Handler（也就是我们平常说的 Controller 控制器） ，并会将请求涉及到的拦截器和 Handler 一起封装。 DispatcherServlet 调用 HandlerAdapter适配器执行 Handler 。 Handler 完成对用户请求的处理后，会返回一个 ModelAndView 对象给DispatcherServlet，ModelAndView 顾名思义，包含了数据模型以及相应的视图的信息。Model 是返回的数据对象，View 是个逻辑上的 View。 ViewResolver 会根据逻辑 View 查找实际的 View。 DispaterServlet 把返回的 Model 传给 View（视图渲染）。 把 View 返回给请求者（浏览器） 上述流程是传统开发模式（JSP，Thymeleaf 等）的工作原理。 对于前后端分离时，后端通常不再返回具体的视图，而是返回纯数据（通常是 JSON 格式，Spring 会自动将其转换为 JSON 格式），由前端负责渲染和展示。 1. Spring 循环依赖了解吗，怎么解决？ 两个或多个 Bean 之间相互持有对方的引用。 @Component public class CircularDependencyA { @Autowired private CircularDependencyB circB; } @Component public class CircularDependencyB { @Autowired private CircularDependencyA circA; } 有三级缓存： 一级缓存（singletonObjects）：存放最终形态的 Bean（已经实例化、属性填充、初始化），单例池，为“Spring 的单例属性”⽽⽣。一般情况我们获取 Bean 都是从这里获取的，但是并不是所有的 Bean 都在单例池里面，例如原型 Bean 就不在里面。 二级缓存（earlySingletonObjects）：存放过渡 Bean（半成品，尚未属性填充，未进行依赖注入），也就是三级缓存中ObjectFactory产生的对象，与三级缓存配合使用的，可以防止 AOP 的情况下，每次调用ObjectFactory#getObject()都是会产生新的代理对象的。 三级缓存（singletonFactories）：存放ObjectFactory，ObjectFactory的getObject()方法（最终调用的是getEarlyBeanReference()方法）可以生成原始 Bean 对象或者代理对象（如果 Bean 被 AOP 切面代理）。三级缓存只会对单例 Bean 生效。 先去 一级缓存 singletonObjects 中获取，存在就返回； 如果不存在或者对象正在创建中，于是去 二级缓存 earlySingletonObjects 中获取； 如果还没有获取到，就去 三级缓存 singletonFactories 中获取，通过执行 ObjectFacotry 的 getObject() 就可以获取该对象，获取成功之后，从三级缓存移除B，并将B对象加入到二级缓存中。 步骤 1：创建 Bean A Spring 容器开始创建 Bean A，首先将 Bean A 的创建状态标记为 “正在创建”。 实例化 Bean A，将 Bean A 的早期引用（一个 ObjectFactory 对象）放入三级缓存 singletonFactories 中。这个 ObjectFactory 对象可以在需要时返回 Bean A 的早期实例。 开始对 Bean A 进行属性注入，发现 Bean A 依赖于 Bean B。 步骤 2：创建 Bean B Spring 容器开始创建 Bean B，同样将 Bean B 的创建状态标记为 “正在创建”。 实例化 Bean B，将 Bean B 的早期引用放入三级缓存 singletonFactories 中。 开始对 Bean B 进行属性注入，发现 Bean B 依赖于 Bean A。 步骤 3：解决 Bean B 对 Bean A 的依赖 当 Bean B 需要注入 Bean A 时，Spring 容器首先从一级缓存 singletonObjects 中查找 Bean A，发现没有找到。 接着从二级缓存 earlySingletonObjects 中查找，也没有找到。 然后从三级缓存 singletonFactories 中查找，找到了 Bean A 的早期引用（ObjectFactory 对象）。 调用 ObjectFactory 的 getObject() 方法，获取 Bean A 的早期实例。如果 Bean A 需要进行 AOP 代理，会在这里创建代理对象，并将代理对象放入二级缓存 earlySingletonObjects 中，同时从三级缓存 singletonFactories 中移除该引用。 将获取到的 Bean A 的早期实例注入到 Bean B 中。 步骤 4：完成 Bean B 的创建 Bean B 完成属性注入后，进行初始化操作。 将完全创建好的 Bean B 实例放入一级缓存 singletonObjects 中，并从二级缓存 earlySingletonObjects 和三级缓存 singletonFactories 中移除相关引用。 步骤 5：完成 Bean A 的创建 由于 Bean B 已经创建完成，将 Bean B 实例注入到 Bean A 中。 Bean A 完成属性注入后，进行初始化操作。 将完全创建好的 Bean A 实例放入一级缓存 singletonObjects 中，并从二级缓存 earlySingletonObjects 和三级缓存 singletonFactories 中移除相关引用。 1. 什么是 Spring Boot Starters? Spring Boot Starters 是一组便捷的依赖描述符，它们预先打包了常用的库和配置。当我们开发 Spring 应用时，只需添加一个 Starter 依赖项，即可自动引入所有必要的库和配置，快速引入相关功能。 在没有 Spring Boot Starters 之前，开发一个 RESTful 服务或 Web 应用程序通常需要手动添加多个依赖，比如 Spring MVC、Tomcat、Jackson 等。这不仅繁琐，还容易导致版本不兼容的问题。而有了 Spring Boot Starters，我们只需添加一个依赖，如 spring-boot-starter-web，即可包含所有开发 REST 服务所需的库和依赖。 这个 spring-boot-starter-web 依赖包含了 Spring MVC（用于处理 Web 请求）、Tomcat（默认嵌入式服务器）、Jackson（用于 JSON 处理）等依赖项。这种方式极大地简化了开发过程，让我们可以更加专注于业务逻辑的实现。 2. 介绍一下@SpringBootApplication 注解 @EnableAutoConfiguration: 启用 Spring Boot 的自动配置机制。它是自动配置的核心，允许 Spring Boot 根据项目的依赖和配置自动配置 Spring 应用的各个部分。 @ComponentScan: 启用组件扫描，扫描被 @Component（以及 @Service、@Controller 等）注解的类，并将这些类注册为 Spring 容器中的 Bean。默认情况下，它会扫描该类所在包及其子包下的所有类。 @Configuration: 允许在上下文中注册额外的 Bean 或导入其他配置类。它相当于一个具有 @Bean 方法的 Spring 配置类。 3. Spring Boot 的自动配置是如何实现的? Spring Boot 通过@EnableAutoConfiguration开启自动装配，通过 SpringFactoriesLoader 最终加载META-INF/spring.factories中的自动配置类实现自动装配. HTTP和HTTPS二者区别 HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。 HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。 HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。 对称+非对称、摘要算法+数字签名、身份证书 TCP、UDP区别、应用场景 MySQL 基础架构 1. 结构 连接器： 身份认证和权限相关(登录 MySQL 的时候)。 查询缓存： 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。 分析器： 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。 优化器： 按照 MySQL 认为最优的方案去执行。 执行器： 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。 插件式存储引擎：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。InnoDB 是 MySQL 的默认存储引擎，绝大部分场景使用 InnoDB 就是最好的选择。 2. SQL语句在MySQL中的执行过程 查询语句的执行流程如下：权限校验（如果命中缓存）--->查询缓存--->分析器--->优化器--->权限校验--->执行器--->引擎 更新语句执行流程如下：分析器---->权限校验---->执行器--->引擎---redo log(prepare 状态)--->binlog--->redo log(commit 状态) Redis单线程怎么监视IO连接？ Redis 通过 IO 多路复用程序 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。 I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗。 Redis I/O复用的三种实现方式？复杂度 建议deepseek问一下。 select：轮寻，O(n) poll：轮寻，O(n) Epoll: 基于事件触发，O(1) Redis ZSet的底层实现 重点关注跳表的原理，复杂度，为什么要采用两种实现。 缓存击穿、缓存穿透、缓存雪崩 如何解决？是结合黑马点评问的。 如何保障数据库和缓存的一致性。 旁路缓存模式：先修改数据库，在删除缓存。 说说hashmap，线程安全吗？哈希冲突怎么解决？说说扩容？升级红黑树的阈值，降为链表的阈值？为什么二者不一样。 看javaguide。 阈值是8和6，防止频繁的转换。 聊聊JVM的内存区域 很重要，建议javaguide。 线程的：栈、程序计数器。 进程的：堆。方法区 聊聊垃圾回收器G1的回收过程？优点是什么？ javaguide。 聊聊对象在JVM的移动（Eden->S1和S2->老年代），为什么老年区占空间大于新生区？ 很重要，注意数组等大对象直接放在老年区。 面向对象三个特点？多态的实现方式？ 见javaguide。 重载和重写的区别？ 见javaguide。关注一下重载发生在编译器，重写发生在运行期。 Copyright © 版权信息 all right reserved，powered by aspire-zero and Gitbook该文件修订时间： 2025-02-23 15:02:48 "}}