# 基础知识

## 1. 什么是设计模式？

是指在软件开发过程中，针对反复出现的问题所总结归纳出的通用解决方案。

使⽤设计模式是为了重⽤代码、让代码更容易被他⼈理解、保证代码可靠性。

## 2. 设计模式的分类了解吗？

- **创建型：** 在创建对象的同时隐藏创建逻辑，不使⽤ new 直接实例化对象，程序在判断需要创建哪些对象时更灵活。
  - 包括⼯⼚/抽象⼯⼚/单例/建造者/原型模式。
- **结构型：** 通过类和接⼝间的继承和引⽤实现创建复杂结构的对象。
  - 包括适配器/桥接模式/过滤器/组合/装饰器/外观/享元/代理模式。
- **⾏为型：** 通过类之间不同通信⽅式实现不同⾏为。
  - 包括责任链/命名/解释器/迭代器/中介者/备忘录/观察者/状态/策略/模板/访问者模式。

## 3. 你知道哪些设计模式？

![image-20250204161600594](https://acwhr.oss-cn-beijing.aliyuncs.com/typora_images/202502041616630.png)

# 创建型模式

## 1. 单例模式

⼀个单例类在任何情况下都只存在⼀个实例。

- **构造⽅法必须是私有的**。
- 由⾃⼰创建⼀个**静态变量**存储实例。
- 对外提供⼀个**静态公有⽅法**获取实例。

**例子**：Spring 框架里，单例 Bean 就遵循了单例模式的核心思想，在整个 Spring 应用上下文中，一个单例 Bean 只会有一个实例存在。

~~~java
//线程安全的单例模式
public class Singleton {
    // 使用 volatile 关键字确保 instance 的可见性
    private static volatile Singleton instance;

    // 私有构造函数，防止外部实例化
    private Singleton() {
        // 初始化代码
    }

    // 获取单例实例的静态方法
    public static Singleton getInstance() {
        // 第一次检查，避免不必要的同步
        if (instance == null) {
            // 加锁，确保线程安全
            synchronized (Singleton.class) {
                // 第二次检查，防止多个线程同时通过第一次检查
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
~~~

## 2. 简单工厂模式

由⼀个⼯⼚对象来创建实例，客户端不需要关注创建逻辑，只需提供传⼊⼯⼚的参数。

**缺点**：适⽤于⼯⼚类负责创建对象较少的情况，缺点是如果要增加新产品，就需要修改⼯⼚类的判断逻辑，违背开闭原则，且产品多的话会使⼯⼚类⽐较复杂。

**例子：**

- Calendar 抽象类的 getInstance ⽅法，调⽤ createCalendar ⽅法根据不同的地区参数创建不同的⽇历对象。
- Spring 中的 BeanFactory 使⽤简单⼯⼚模式，根据传⼊⼀个唯⼀的标识来获得 Bean 对象。



![image-20250204162139656](https://acwhr.oss-cn-beijing.aliyuncs.com/typora_images/202502041621678.png)

## 3. ⼯⼚⽅法模式

也就是定义⼀个抽象⼯⼚，其定义了产品的⽣产接⼝，但不负责具体的产品，将⽣产任务交给不同的具体⼯⼚。

这样不⽤通过指定类型来创建对象了，而是直接使用具体工厂。

**注意：工厂方法模式主要关注单个产品的创建，每个具体工厂类只负责创建一种具体产品。**

![image-20250204162502274](https://acwhr.oss-cn-beijing.aliyuncs.com/typora_images/202502041625303.png)

## 4. 抽象⼯⼚模式

简单⼯⼚模式和⼯⼚⽅法模式不管⼯⼚怎么拆分抽象，都只是针对⼀类产品，如果要⽣成另⼀种产品，就⽐较难办了！

- 工厂方法模式主要关注单个产品的创建，每个具体工厂类只负责创建一种具体产品。
- 而抽象工厂模式关注的是创建一系列相关的产品，一个具体工厂类可以创建多种不同类型的产品。

![image-20250204162924921](https://acwhr.oss-cn-beijing.aliyuncs.com/typora_images/202502041629945.png)

## 5. 建造者模式

# 结构性模式

## 1. 适配器模式

所谓适配器模式就是将⼀个类的接⼝，转换成客户期望的另⼀个接⼝。它可以让原本两个不兼容的接⼝能够⽆缝完成对接。

作为中间件的适配器将⽬标类和适配者解耦，增加了类的透明性和可复⽤性。

应用：旧的库存管理系统提供了一个以 XML 格式返回库存信息的接口，而新的销售系统需要的是 JSON 格式的数据。为了让新系统能够使用旧系统的库存信息，可以创建一个适配器类，将旧系统返回的 XML 数据转换为 JSON 数据。

![image-20250204164105759](https://acwhr.oss-cn-beijing.aliyuncs.com/typora_images/202502041641784.png)

![image-20250204164142889](https://acwhr.oss-cn-beijing.aliyuncs.com/typora_images/202502041641914.png)

## 2. 代理模式

使⽤者通过代理**间接的访问服务提供者**，便于后者的封装和控制，主要⽬的是解耦合服务提供者和使⽤者。

**例子**：SpringAop的实现。

![image-20250204164540721](https://acwhr.oss-cn-beijing.aliyuncs.com/typora_images/202502041645745.png)

## 3. 装饰器模式

装饰器模式主要对现有的类对象进⾏包裹和封装，以期望在不改变类对象及其类定义的情况下，为对象添加额外功能。

如果你希望在⽆需修改代码的情况下即可使⽤对象， 且希望在运⾏时为对象新增额外的⾏为， 可以使⽤装饰模式。

在java的IO流中较为常用。

~~~java
InputStream fileInputStream = new FileInputStream("test.txt");
// 使用具体装饰器：BufferedInputStream 进行装饰
InputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
~~~



![image-20250204175044009](https://acwhr.oss-cn-beijing.aliyuncs.com/typora_images/202502041750037.png)

# 行为型模式

## 1. 策略模式

其⽤意是针对⼀组算法，将每⼀个算法封装到具有共同接⼝的独⽴的类中，从⽽使得它们可以相互替换。

应用：线程次的拒绝策略，需要传入一个策略。

好处：可以灵活切换。

## 2. 观察者模式

也称为发布订阅模式。

观察者模式主要⽤于处理对象间的⼀对多的关系，当⼀个对象状态发⽣变化时，所有该对象的关注者均能收到状态变化通知，以进⾏相应的处理。

核心：添加观察者，通知观察者。

应用：

**Spring 的事件驱动模型**：Spring 框架提供了一套事件驱动模型，本质上是基于观察者模式实现的。主要有三个核心元素：`ApplicationEvent`（事件）、`ApplicationListener`（事件监听器，即观察者）和`ApplicationEventPublisher`（事件发布者，即被观察者）。

- 例如，在一个 Web 应用中，当用户成功登录时，可以发布一个自定义的登录成功事件，然后有相关的监听器来处理这个事件，比如记录登录日志、更新用户在线状态等。

![image-20250204181858825](https://acwhr.oss-cn-beijing.aliyuncs.com/typora_images/202502041818857.png)

## 3. 责任链模型

⼀个请求沿着⼀条“链”传递，直到该“链”上的某个处理者处理它为⽌。

请求者不关心谁去处理，处理者不需要知道请求的全貌。

例子：

请假审批：假设员工请假天数不同，审批人不同。如果员工请假天数小于等于 3 天，由直属主管审批；如果请假天数大于 3 天且小于等于 7 天，由部门经理审批；如果请假天数大于 7 天，由总经理审批。这里可以将直属主管、部门经理、总经理看作责任链上的节点。

web过滤器链：

![image-20250204183542267](https://acwhr.oss-cn-beijing.aliyuncs.com/typora_images/202502041835301.png)