# 黑马点评

## 1. 登录功能

**描述**：使用 Redis缓存 token 解决集群模式下的 Session 共享问题，使用拦截器实现用户的登录校验?

---

**问题1**：集群模式下的 Session 共享问题是什么？

**答案1**：多台Tomcat并不共享session存储空间，集群模式，当请求切换到不同tomcat服务时导致数据丢失的问题。

---

**问题2**：你来说说传统的Session和cookie，或者二者的关系？

**答案2**：

当用户首次访问Web应用时，服务器会自动创建一个新的session。这通常是通过调用`HttpServletRequest.getSession(true)`来实现的，其中`true`参数表示如果不存在session，则创建一个新的session，session有一个id，id被存储在客户端的cookie中。

如果客户端的cookie没有被删除，当用户再次请求服务器时候，服务器就能根据cookie中的sessionid来在tomcat中获得session。

如果用户长时间没有访问服务器，服务器的session可能会过期，即使此时客户端的cookie没有被删除，也会要求用户重新登录，服务器会为用户分配一个新的Session ID，并将其发送回客户端。客户端（浏览器）会更新Cookie中的Session ID，以便后续的请求使用新的会话标识。这样做是为了确保会话的安全性，防止旧的、可能被泄露的Session ID被滥用。

---

**问题3**：在实现 Session 共享时，使用 Redis 缓存 token 的具体流程是怎样的？

**答案3**：

如果用户成功登录，会生产一个代表用户的唯一token，然后用token当做redis的键，我采用hash结构存储，值是用户的信息，这里设置个有效期，用户长时间未登录，就会过期。

前端可使用浏览器的SessionStorage存储token，然后给ajox添加一个拦截器，所有从前端发送的请求都在header里面加上一个字段'authorization'存放token。

---

**问题4**：你的唯一token是如何获取的？怎么保证不可重复？

**答案4**：使用`UUID.randomUUID()`方法，具有全球唯一性。在分布式系统、数据库主键生成、令牌生成等场景中有广泛应用。

理论上它有 2 的 128 次方个不同的取值，结合了时间戳、mac地址、随机数。

---

**问题5**：讲讲双层拦截器，第一层和第二层需要干什么？

第一层拦截器：用户在登录状态点击链接，应该会重置有效期，因此第一层拦截器，需要拦截所有路径。

1. 获取header中的token
2. 去redis中根据token查询用户信息
3. 如果查的到，需要把用户信息放到threadlocal里面，查不到不用管。
4. 更新redis的过期时间
5. 放行

第二层拦截器：有些页面只有登录才能访问，比如个人信息，秒杀页面。

1. 查看ThreadLocal有没有用户
2. 有的话方向，没的话拦截。

----

**问题6**：为什么使用ThreadLocal保存用户信息，讲讲原理，ThreadLocal有什么问题？（内存泄漏）。

当客户端发送一个请求到服务器时，服务器会分配一个线程来处理这个请求。多个用户之间的线程有各自的用户信息，应该互不干扰，因此使用TreadLocal。

原理：

**每个`Thread`中都具备一个`ThreadLocalMap`，而`ThreadLocalMap`可以存储以`ThreadLocal`为 key ，Object 对象为 value 的键值对。**

ThreadLocalMap 理解为ThreadLocal 类实现的定制化的 HashMap。

问题：

如果使用完，忘记remove会出现内存泄漏。

根本原因：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，与key是弱引用无关，反而弱引用多了一层保障。

`ThreadLocal` 实例不再被强引用，由于是弱引用，它会被垃圾回收，导致键变为null，但值Value是强引用，不会被回收；并且，线程持续存活，导致 `ThreadLocalMap` 长期存在。此外虽然 `ThreadLocalMap` 在 `get()`, `set()` 和 `remove()` 操作时会尝试清理 key 为 null 的 entry，但这种清理机制是被动的，并不完全可靠。

----

**问题7**：怎么实现的手机号登录？

先用正则表达式验证手机号是否符合格式，符合格式的话，生成一个验证码，让以手机号为key，验证码为value存入redis中，设置过期时间，然后发送短信。

用户再次提交手机号和验证码的表单，然后用手机号为key去查redis，如果值是value，则表示登录成功。然后根据手机号去数据库中查询，生成一个token，把用户信息保存到redis中，然后返回给前段token。

## 2. 缓存优化

**问题1**：什么信息放在了缓存里面，为什么要使用缓存？

比如商户信息，优惠券信息，商户类别信息，因为这些信息经查需要被查询，放到缓存里面可以提高访问速度，降低数据库压力。

---

**问题2**：如何保证数据库与缓存的一致性？

使用旁路缓存模式，如果需要更新数据库，直接删除缓存。然后使用设置超时时间作为保底策略。



至于为什么不是更新缓存，因为这样可能会出现：这段时间我们一直更新缓存，但是压根没人来查询。

至于为什么是先更新数据库，在删除缓存。是因为更新数据库需要时间比较长。

A删除缓存->B查询缓存未命中，查询数据库中的旧数据，把旧数据写入缓存->A更新数据库为新数据。

反过来，出现数据不一致的概率很低，因为缓存的写入速度是比数据库的写入速度快很多，需要在很短的时间内更新数据库才会出现缓存不一致。

![image-20241016164359215](https://acwhr.oss-cn-beijing.aliyuncs.com/typora_images/202502081516092.png)



a线程去更新，先更新数据库，这时候b线程来查了，由于a线程还没有删除缓存，b线程查的不是旧数据吗？

使用锁或者延迟双删：

- 1. 线程 A 先删除缓存。
  2. 线程 A 更新数据库。
  3. 线程 A 延迟一段时间（如几百毫秒），再次删除缓存。
- **目的**：
  - 第一次删除缓存：确保在更新数据库之前，缓存中没有旧数据。
  - 第二次删除缓存：确保在更新数据库之后，清理可能被其他线程写入的旧数据。

---



**问题3**：除了旁路缓存，你还知道什么策略？

读写穿透：缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。

缺点：还需要完成redis写入数据库的过程。

异步缓存写入：调用者只操作缓存，由其它线程异步的将缓存数据持久化到数据库，保证最终一致。

---

## 3. 缓存穿透和雪崩保护

**问题1：**什么是缓存穿透，你如何解决的？

缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。

解决方案：

首先使用布隆过滤器，如果布隆过滤器不放行，呢么说明是非法请求。如果放行，有很低的概率是非法请求，这个时候采用缓存一个空数据（设置较短的TTL），如果用户频繁使用这个能够穿透布隆过滤器的id进行非法攻击，可以让redis去处理请求。

其他方案：

- 增强id的复杂度，避免被猜测id规律
- 做好数据的基础格式校验，校验id是否合法，过短和过长的id直接可以pass掉
- 加强用户权限校验，比如一些页面必须登录才能操作
- 做好热点参数的限流，监测到商品被访问的特别多，可以加限流：利用 Redis 的原子操作（如 `INCR` 和 `EXPIRE`）来记录每个热点参数（商品 ID）的访问次数，当访问次数超过预设的阈值时，对该参数的请求进行限流。

---

**问题3：**什么是缓存雪崩，你如何解决的？

缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。

• 给不同的Key的TTL添加随机值
• 利用Redis集群提高服务的可用性（哨兵、集群）
• 给业务添加多级缓存（浏览器缓存、Nginx缓存、redis缓存、Tomcat缓存）

---

**问题4：**什么是缓存击穿，你如何解决的？

一件秒杀中的商品的key突然失效了，大家都在疯狂抢购，那么这个瞬间就会有无数的请求访问去直接抵达数据库，从而造成缓存击穿。

如果重建缓存需要**多个表查询**，这样重建过程可能得到几百毫秒，这时候又来无数请求访问，都在重建，数据库可能会宕机。

我使用逻辑过期：假设线程1去查询缓存，然后从value中判断当前数据已经过期了，此时线程1去获得互斥锁，获得了锁的进程他会**开启一个新线程**去进行之前的重建缓存数据的逻辑，直到新开的线程完成者逻辑之后，才会释放锁，而线程1直接进行返回，假设现在线程3过来访问，由于线程2拿着锁，所以线程3无法获得锁，线程3也直接返回数据旧数据，牺牲了数据一致性，换取性能上的提高，只有等待线程2重建缓存数据之后，其他线程才能返回正确的数据。

---



**问题5**：除了逻辑过期，还有什么能够解决缓存击穿？

可以使用锁，但是拿不到锁的线程需要等待，降低了响应速度。

---

**问题6**：在集群模式下重建缓存时的线程安全问题？为什么要使用Redisson？

在分布式系统中，应用通常会部署在不同的服务器， Java 虚拟机本地锁无法跨服务器。可能出现多个服务器的多个线程同时获得了本地锁，都去重建缓存。

Redisson 基于redis，它提供了简单易用且功能强大的分布式锁实现。在重建缓存时，可以使用 Redisson 的分布式锁来保证同一时刻只有一个线程能够进行缓存重建操作。

---

**问题7**：Redisson锁你了解吗？

- 可重入：利用hash结构记录线程id和重入次数，**外层key**表示这把锁是否存在，**内层ke**y则记录当前这把锁被**哪个线程持有**，**value**存当前这个锁被**获取了几次**。为了保证**原子性**，所以流程图中的业务逻辑也是需要我们用**Lua**来实现的。
- 可重试：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制，不浪费cpu资源。获取锁成功，返回nil（java里面接受的是null）。获取锁失败，返回剩余到期时间
- 超时续约：利用watchD0g，每隔一段时间(releaseTime/3)，重置超时时间，也就是重新expire。

---

## 4. 秒杀系统优化

**问题1**：如何利用Redis的Lua 脚本在库存判断和用户一人一单校验时保证原子性？



首先，这做了读写分离，我们将耗时较短的**查询**逻辑判断放到Redis中，例如：库存是否充足，是否一人一单这样的操作，只要满足这两条操作，那我们是一定可以下单成功的，不用等数据真的写进数据库，因为这样实际上用户已经完成了下单，他获得了订单号，只要去支付就行了。

然后后台再开一个线程，后台线程再去读取阻塞队列里的消息，执行操作慢的数据库写操作。

我们使用lua脚本：先判断库存是否充足，在判断用户有没有下过单，最后在扣减库存，如果不保证原子性，就会出现并发问题。

静态代码块加载lua脚本。

~~~lua
-- 订单id
local voucherId = ARGV[1]
-- 用户id
local userId = ARGV[2]
-- 新增orderId，但是变量名用id就好，因为VoucherOrder实体类中的orderId就是用id表示的
local id = ARGV[3]
-- 优惠券key
local stockKey = 'seckill:stock:' .. voucherId
-- 订单key
local orderKey = 'seckill:order:' .. voucherId
-- 判断库存是否充足
if (tonumber(redis.call('get', stockKey)) <= 0) then
    return 1
end
-- 判断用户是否下单
if (redis.call('sismember', orderKey, userId) == 1) then
    return 2
end
-- 扣减库存
redis.call('incrby', stockKey, -1)
-- 将userId存入当前优惠券的set集合
redis.call('sadd', orderKey, userId)
-- 将下单数据保存到消息队列中
redis.call("xadd", 'stream.orders', '*', 'voucherId', voucherId, 'userId', userId, 'id', id)
return 0
~~~



~~~java
public Result seckillVoucher(Long voucherId) {
        Long userId = UserHolder.getUser().getId();
        //1执行脚本,第一个参数是脚本，第二个参数是KEY的list结合，第三个参数是可变参数（其他变量）
        Long isSuccess = stringRedisTemplate.execute(
                SECKILL_SCRIPT,
                Collections.emptyList(),
                voucherId.toString(),
                userId.toString()
        );
        //2如果返回的不是0，表示下单失败
        if(isSuccess == 1L){
            return Result.fail("库存不足！");
        } else if(isSuccess == 2L){
            return Result.fail("不允许重复下单！");
        }
        long orderId = redisIdWorker.nextId("order");
        //3 订单加入到阻塞队列
        VoucherOrder voucherOrder = new VoucherOrder(orderId, userId, voucherId);
        //子线程看不到代理对象，因此把代理对象弄成成员变量。
        proxy = (IVoucherOrderService) AopContext.currentProxy();
        orderTasks.add(voucherOrder);
        return Result.ok(orderId);
    }
~~~



---



**问题2**：如何并使用乐观锁解决秒杀中的超卖问题。

理论上，redis已经保证了不会出现超卖，这里是使用乐观锁做保底处理，保证数据库不会出现超卖，update的where条件加入一个判断库存>0。

## 5. 异步秒杀下单

**问题1**：为什么基于 Redis 的Stream结构作为消息队列？讲一下Redis 的Stream结构。

**消息持久化**：Redis 的 Stream 支持消息持久化，消息会被写入磁盘，即使 Redis 服务器重启，消息也不会丢失。

**消息标识**：消费者组会维护一个标识，记录组内**最后一个被处理的消息**，哪怕消费者宕机重启，还会从标识之后读取消息，确保每一个消息都会被消费。**注意组内只会维护一个标记。**

**消息确认机制**：消费者获取消息后，消息处于**pending**状态，并存入一个pending-list，当处理完成后，需要通过XACK来确认消息，标记消息为已处理，才会从pending-list中移除。

---



**问题2**：如何实现的？

项目一启动，就用开启一个独立的线程，线程使用while循环加XREADGROUP阻塞读取订单消息，然后创建订单，如果处理完成就使用xack进行确认消息。如果这个过程发生了异常，使用xpending专门读取未确认的消息。

# 动态线程池

**问题1**：为什么要实现一个动态线程池？传统的线程池有什么缺点？

动态线程池是一种能够在应用程序运行过程中，无需重启服务即可实时调整其核心配置参数（如核心线程数、最大线程数等）的线程池机制。

传统线程池存在的痛点：

- **参数不可动态修改**：传统线程池的参数（如核心线程数、最大线程数和任务队列大小）在创建时被固定。随着**业务负载的变化**，这种固定配置难以适应，需要调整时必须重启服务，过程繁琐且耗时。
- **缺乏实时反馈**：不知道线程的运行状况，例如当前线程数、是否开始执行拒绝策略、当前的队列长度，缺乏有效的运行时监控和告警机制，难以及时发现并响应问题。
- **问题难定位**：当线程池运行出现问题例如发生线程池拒绝，无法及时捕捉线程堆栈信息，从而难以快速定位问题原因。

---

**问题2**：你能够动态修改哪些参数？如何实现？为什么不动态修改队列。

核心线程数、最大线程数。

前段提交更新后，后端监听线程池参数配置，使用线程池的set方法更改参数。

---

**问题3**：讲一下将线程池的实时运行状态进行上报

借用spring的`@Scheduled`注解，当然记得要在配置了加上`@EnableScheduling`。每20秒查询本地线程池的运行状况，然后把运行状况保存到redis中（键使用前缀+应用名+线程池名）。

这里使用了redissonClient的RList和RBucket数据结构，分别使用是用list和string实现的。

---

**问题4**：讲一下redis的发布订阅模型，你如何使用他实现更新参数的。

这是一个通信模型，消息发布者将消息发送到特定的频道（channel），而订阅者则可以订阅一个或多个频道，当有消息发布到其订阅的频道时，订阅者会收到相应的消息。

1. 我们使用redissonClient的Rtopic，根据被修改线程池的应用名称获得频道topic，然后相频道中发送修改后的线程实体。
2. 我们首先需要在配置类让这个订阅者订阅自己的频道（topic.addListener）。
3. 然后，后端监听类需要实现MessageListener接口，然后实现onMessage方法。
4. 当发布者发布消息的时候，后端监听类这个订阅者就能收到修改后的线程池实体，然后直接修改就行，修改完之后上报。

---

**问题5**：日志与预警处理是怎么实现的？

拒绝日志：我们需要自定义一个拒绝策略类，需实现 `RejectedExecutionHandler` 接口，并重写 `rejectedExecution` 方法，把拒绝信息存入redis中。

我们的定时任务查询线程池运行状况的时候，会检查队列当前大小是否大于设定的阈值，如果大于，则把预警信息存入redis中，前段会定时查询日志和预警，当然这里预警的时候，我们也可以实现一个功能，比如给管理者发送短信。

---

**问题6**：设置核心线程数小于当前运行的任务线程数怎么办？

核心线程不会立即销毁，需要继续执行任务，包括队列中积压的任务，当核心线程空闲的时候，才会销毁。